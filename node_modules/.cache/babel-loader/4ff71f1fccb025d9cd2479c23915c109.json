{"ast":null,"code":"\"use strict\";\n\nvar __importStar = this && this.__importStar || function (mod) {\n  if (mod && mod.__esModule) return mod;\n  var result = {};\n  if (mod != null) for (var k in mod) if (Object.hasOwnProperty.call(mod, k)) result[k] = mod[k];\n  result[\"default\"] = mod;\n  return result;\n};\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar helpers_1 = require(\"./helpers\");\n\nvar G = __importStar(require(\"./globals\"));\n/** Create a frameloop singleton */\n\n\nvar FrameLoop =\n/** @class */\nfunction () {\n  function FrameLoop( // The global `requestAnimationFrame` must be dereferenced to avoid \"Illegal invocation\" errors\n  requestFrame) {\n    if (requestFrame === void 0) {\n      requestFrame = function (fn) {\n        return (void 0, G.requestAnimationFrame)(fn);\n      };\n    }\n\n    var idle = true;\n    var writing = false; // The most recent framestamp\n\n    var lastTime = 0; // The active animations for the current frame, sorted by lowest priority first\n\n    var animations = []; // The priority of the currently advancing animation.\n    // To protect against a race condition whenever a frame is being processed,\n    // where the filtering of `animations` is corrupted with a shifting index,\n    // causing animations to potentially advance 2x faster than intended.\n\n    var priority = 0; // Animations starting on the next frame\n\n    var startQueue = new Set(); // Flushed after all animations are updated.\n    // Used to dispatch events to an \"onFrame\" prop, for example.\n\n    var frameQueue = new Set(); // Flushed at the very end of each frame.\n    // Used to avoid layout thrashing in @react-spring/web, for example.\n\n    var writeQueue = new Set(); // Add an animation to the frameloop\n\n    var start = function (animation) {\n      var index = animations.findIndex(function (other) {\n        return other.priority > animation.priority;\n      });\n      animations.splice(~index ? index : animations.length, 0, animation);\n      kickoff();\n    }; // Start the frameloop\n\n\n    var kickoff = function () {\n      if (idle) {\n        idle = false;\n        lastTime = G.performanceNow();\n        requestFrame(update);\n      }\n    }; // Process the current frame\n\n\n    var update = this.update = function (time) {\n      if (idle) return;\n\n      if (helpers_1.is.und(time)) {\n        time = G.performanceNow();\n      }\n\n      var dt = time - lastTime;\n\n      if (dt > 0) {\n        // http://gafferongames.com/game-physics/fix-your-timestep/\n        if (dt > 64) dt = 64;\n\n        if (startQueue.size) {\n          startQueue.forEach(start);\n          startQueue.clear();\n        } // Animations can be added while the frameloop is updating,\n        // but they need a higher priority to be started on this frame.\n\n\n        if (animations.length) {\n          animations = animations.filter(function (animation) {\n            priority = animation.priority; // Animations may go idle before the next frame.\n\n            if (!animation.idle) {\n              animation.advance(dt);\n            } // Remove idle animations.\n\n\n            return !animation.idle;\n          });\n          priority = 0;\n        }\n\n        if (frameQueue.size) {\n          frameQueue.forEach(function (onFrame) {\n            return onFrame(time);\n          });\n          frameQueue.clear();\n        }\n\n        if (writeQueue.size) {\n          writing = true;\n          writeQueue.forEach(function (write) {\n            return write(time);\n          });\n          writeQueue.clear();\n          writing = false;\n        }\n\n        if (!animations.length) {\n          idle = true;\n          return;\n        }\n      }\n\n      lastTime = time;\n      requestFrame(update);\n    };\n\n    this.start = function (animation) {\n      var index = animations.indexOf(animation);\n\n      if (~index) {\n        animations.splice(index, 1);\n      }\n\n      if (priority > animation.priority) {\n        startQueue.add(animation);\n      } else {\n        start(animation);\n      }\n    };\n\n    this.onFrame = function (cb) {\n      frameQueue.add(cb);\n      kickoff();\n    };\n\n    this.onWrite = function (cb) {\n      if (writing) cb(lastTime);else writeQueue.add(cb);\n    };\n  }\n\n  return FrameLoop;\n}();\n\nexports.FrameLoop = FrameLoop;","map":{"version":3,"sources":["../src/FrameLoop.ts"],"names":[],"mappings":"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","sourcesContent":["import { FrameRequestCallback } from './types'\nimport { is } from './helpers'\nimport * as G from './globals'\n\nexport type RequestFrameFn = (cb: FrameRequestCallback) => number | void\n\nexport interface OpaqueAnimation {\n  idle: boolean\n  priority: number\n  advance(dt: number): void\n}\n\n/** Create a frameloop singleton */\nexport class FrameLoop {\n  /**\n   * Start a new animation, or reorder an active animation in\n   * the animations array in response to a priority change.\n   */\n  start: (animation: OpaqueAnimation) => void\n\n  /**\n   * Update every active animation.\n   *\n   * Can be passed to `requestAnimationFrame` without wrapping or binding.\n   */\n  update: (time?: number) => void\n\n  /**\n   * Execute a function once after all animations have updated.\n   */\n  onFrame: (cb: FrameRequestCallback) => void\n\n  /**\n   * Execute a function once at the very end of the current frame.\n   *\n   * Only call this within an `onFrame` callback.\n   */\n  onWrite: (cb: FrameRequestCallback) => void\n\n  constructor(\n    // The global `requestAnimationFrame` must be dereferenced to avoid \"Illegal invocation\" errors\n    requestFrame: RequestFrameFn = fn => (void 0, G.requestAnimationFrame)(fn)\n  ) {\n    let idle = true\n    let writing = false\n\n    // The most recent framestamp\n    let lastTime = 0\n\n    // The active animations for the current frame, sorted by lowest priority first\n    let animations: OpaqueAnimation[] = []\n\n    // The priority of the currently advancing animation.\n    // To protect against a race condition whenever a frame is being processed,\n    // where the filtering of `animations` is corrupted with a shifting index,\n    // causing animations to potentially advance 2x faster than intended.\n    let priority = 0\n\n    // Animations starting on the next frame\n    const startQueue = new Set<OpaqueAnimation>()\n\n    // Flushed after all animations are updated.\n    // Used to dispatch events to an \"onFrame\" prop, for example.\n    const frameQueue = new Set<FrameRequestCallback>()\n\n    // Flushed at the very end of each frame.\n    // Used to avoid layout thrashing in @react-spring/web, for example.\n    const writeQueue = new Set<FrameRequestCallback>()\n\n    // Add an animation to the frameloop\n    const start = (animation: OpaqueAnimation) => {\n      const index = animations.findIndex(\n        other => other.priority > animation.priority\n      )\n      animations.splice(~index ? index : animations.length, 0, animation)\n      kickoff()\n    }\n\n    // Start the frameloop\n    const kickoff = () => {\n      if (idle) {\n        idle = false\n        lastTime = G.performanceNow()\n        requestFrame(update)\n      }\n    }\n\n    // Process the current frame\n    const update = (this.update = time => {\n      if (idle) return\n      if (is.und(time)) {\n        time = G.performanceNow()\n      }\n\n      let dt = time - lastTime\n      if (dt > 0) {\n        // http://gafferongames.com/game-physics/fix-your-timestep/\n        if (dt > 64) dt = 64\n\n        if (startQueue.size) {\n          startQueue.forEach(start)\n          startQueue.clear()\n        }\n\n        // Animations can be added while the frameloop is updating,\n        // but they need a higher priority to be started on this frame.\n        if (animations.length) {\n          animations = animations.filter(animation => {\n            priority = animation.priority\n\n            // Animations may go idle before the next frame.\n            if (!animation.idle) {\n              animation.advance(dt)\n            }\n\n            // Remove idle animations.\n            return !animation.idle\n          })\n          priority = 0\n        }\n\n        if (frameQueue.size) {\n          frameQueue.forEach(onFrame => onFrame(time))\n          frameQueue.clear()\n        }\n\n        if (writeQueue.size) {\n          writing = true\n          writeQueue.forEach(write => write(time))\n          writeQueue.clear()\n          writing = false\n        }\n\n        if (!animations.length) {\n          idle = true\n          return\n        }\n      }\n\n      lastTime = time\n      requestFrame(update)\n    })\n\n    this.start = animation => {\n      const index = animations.indexOf(animation)\n      if (~index) {\n        animations.splice(index, 1)\n      }\n      if (priority > animation.priority) {\n        startQueue.add(animation)\n      } else {\n        start(animation)\n      }\n    }\n\n    this.onFrame = cb => {\n      frameQueue.add(cb)\n      kickoff()\n    }\n\n    this.onWrite = cb => {\n      if (writing) cb(lastTime)\n      else writeQueue.add(cb)\n    }\n  }\n}\n"],"sourceRoot":""},"metadata":{},"sourceType":"script"}