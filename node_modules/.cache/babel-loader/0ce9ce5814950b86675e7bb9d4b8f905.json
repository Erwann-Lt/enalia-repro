{"ast":null,"code":"import { defineHidden, each, getFluidConfig, Globals, is, createInterpolator, isAnimatedString, useForceUpdate, useIsomorphicLayoutEffect } from '@react-spring/shared';\nimport _extends from '@babel/runtime/helpers/esm/extends';\nimport { createAnimatedTransform, createAnimatedStyle, frameLoop, applyAnimatedValues, getComponentProps } from '@react-spring/shared/globals';\nimport React, { forwardRef, useRef } from 'react';\nconst $node = Symbol.for('Animated:node');\n\nconst isAnimated = value => !!value && value[$node] === value;\n/** Get the owner's `Animated` node. */\n\n\nconst getAnimated = owner => owner && owner[$node];\n/** Set the owner's `Animated` node. */\n\n\nconst setAnimated = (owner, node) => defineHidden(owner, $node, node);\n/** Get every `AnimatedValue` in the owner's `Animated` node. */\n\n\nconst getPayload = owner => owner && owner[$node] && owner[$node].getPayload();\n\nclass Animated {\n  constructor() {\n    setAnimated(this, this);\n  }\n  /** Get every `AnimatedValue` used by this node. */\n\n\n  getPayload() {\n    return this.payload || [];\n  }\n\n}\n/** The `AnimatedProps` class sets this before initializing */\n\n\nAnimated.context = null;\n/** An object containing `Animated` nodes */\n\nclass AnimatedObject extends Animated {\n  constructor(source = null) {\n    super();\n    this.setValue(source);\n  }\n\n  getValue(animated) {\n    if (!this.source) return null;\n    const values = {};\n    each(this.source, (source, key) => {\n      if (isAnimated(source)) {\n        values[key] = source.getValue(animated);\n      } else {\n        const config = getFluidConfig(source);\n\n        if (config) {\n          values[key] = config.get();\n        } else if (!animated) {\n          values[key] = source;\n        }\n      }\n    });\n    return values;\n  }\n  /** Replace the raw object data */\n\n\n  setValue(source) {\n    this.source = source;\n    this.payload = this._makePayload(source);\n  }\n\n  reset() {\n    if (this.payload) {\n      each(this.payload, node => node.reset());\n    }\n  }\n  /** Create a payload set. */\n\n\n  _makePayload(source) {\n    if (source) {\n      const payload = new Set();\n      each(source, this._addToPayload, payload);\n      return Array.from(payload);\n    }\n  }\n  /** Add to a payload set. */\n\n\n  _addToPayload(source) {\n    const config = getFluidConfig(source);\n\n    if (config && Animated.context) {\n      Animated.context.dependencies.add(source);\n    }\n\n    const payload = getPayload(source);\n\n    if (payload) {\n      each(payload, node => this.add(node));\n    }\n  }\n\n}\n\nclass AnimatedStyle extends AnimatedObject {\n  constructor(style) {\n    super(style || null);\n  }\n\n  setValue(style) {\n    super.setValue(style && style.transform && createAnimatedTransform ? _extends({}, style, {\n      transform: createAnimatedTransform(style.transform)\n    }) : style);\n  }\n\n}\n\nGlobals.assign({\n  createAnimatedStyle: style => new AnimatedStyle(style)\n});\n/** An animated number or a native attribute value */\n\nclass AnimatedValue extends Animated {\n  constructor(_value) {\n    super();\n    this._value = _value;\n    this.done = true;\n\n    if (is.num(this._value)) {\n      this.lastPosition = this._value;\n    }\n  }\n\n  static create(from, _to) {\n    return new AnimatedValue(from);\n  }\n\n  getPayload() {\n    return [this];\n  }\n\n  getValue() {\n    return this._value;\n  }\n  /**\r\n   * Set the current value and optionally round it.\r\n   *\r\n   * The `step` argument does nothing whenever it equals `undefined` or `0`.\r\n   * It works with fractions and whole numbers. The best use case is (probably)\r\n   * rounding to the pixel grid with a step of:\r\n   *\r\n   *      1 / window.devicePixelRatio\r\n   */\n\n\n  setValue(value, step) {\n    if (is.num(value)) {\n      this.lastPosition = value;\n\n      if (step) {\n        value = Math.round(value / step) * step;\n\n        if (this.done) {\n          this.lastPosition = value;\n        }\n      }\n    }\n\n    if (this._value === value) {\n      return false;\n    }\n\n    this._value = value;\n    return true;\n  }\n\n  reset() {\n    const {\n      done\n    } = this;\n    this.done = false;\n\n    if (is.num(this._value)) {\n      this.elapsedTime = 0;\n      this.lastPosition = this._value;\n      if (done) this.lastVelocity = null;\n      this.v0 = null;\n    }\n  }\n\n}\n\nclass AnimatedString extends AnimatedValue {\n  constructor(from, to) {\n    super(0);\n    this._string = null;\n    this._toString = createInterpolator({\n      output: [from, to]\n    });\n  }\n\n  static create(from, to = from) {\n    if (is.str(from) && is.str(to)) {\n      return new AnimatedString(from, to);\n    }\n\n    throw TypeError('Expected \"from\" and \"to\" to be strings');\n  }\n\n  getValue() {\n    let value = this._string;\n    return value == null ? this._string = this._toString(this._value) : value;\n  }\n\n  setValue(value) {\n    if (!is.num(value)) {\n      this._string = value;\n      this._value = 1;\n    } else if (super.setValue(value)) {\n      this._string = null;\n    } else {\n      return false;\n    }\n\n    return true;\n  }\n\n  reset(goal) {\n    if (goal) {\n      this._toString = createInterpolator({\n        output: [this.getValue(), goal]\n      });\n    }\n\n    this._value = 0;\n    super.reset();\n  }\n\n}\n/** An array of animated nodes */\n\n\nclass AnimatedArray extends AnimatedObject {\n  constructor(from, to) {\n    super(null);\n    super.setValue(this._makeAnimated(from, to));\n  }\n\n  static create(from, to) {\n    return new AnimatedArray(from, to);\n  }\n\n  getValue() {\n    return this.source.map(node => node.getValue());\n  }\n\n  setValue(newValue) {\n    const payload = this.getPayload(); // Reuse the payload when lengths are equal.\n\n    if (newValue && newValue.length == payload.length) {\n      each(payload, (node, i) => node.setValue(newValue[i]));\n    } else {\n      // Remake the payload when length changes.\n      this.source = this._makeAnimated(newValue);\n      this.payload = this._makePayload(this.source);\n    }\n  }\n  /** Convert the `from` and `to` values to an array of `Animated` nodes */\n\n\n  _makeAnimated(from, to = from) {\n    return from ? from.map((from, i) => (isAnimatedString(from) ? AnimatedString : AnimatedValue).create(from, to[i])) : [];\n  }\n\n}\n\nclass AnimatedProps extends AnimatedObject {\n  constructor(update) {\n    super(null);\n    this.update = update;\n    /** Equals true when an update is scheduled for \"end of frame\" */\n\n    this.dirty = false;\n  }\n\n  setValue(props, context) {\n    if (!props) return; // The constructor passes null.\n\n    if (context) {\n      Animated.context = context;\n    }\n\n    super.setValue(props.style && createAnimatedStyle ? _extends({}, props, {\n      style: createAnimatedStyle(props.style)\n    }) : props);\n    Animated.context = null;\n  }\n  /** @internal */\n\n\n  onParentChange({\n    type\n  }) {\n    if (!this.dirty && type === 'change') {\n      this.dirty = true;\n      frameLoop.onFrame(() => {\n        this.dirty = false;\n        this.update();\n      });\n    }\n  }\n\n}\n\nconst cacheKey = Symbol.for('AnimatedComponent');\n\nconst withAnimated = Component => is.str(Component) ? createAnimatedComponent(Component) : Component[cacheKey] || (Component[cacheKey] = createAnimatedComponent(Component));\n\nconst createAnimatedComponent = Component => forwardRef((rawProps, ref) => {\n  const instanceRef = useRef(null);\n  const hasInstance = // Function components must use \"forwardRef\" to avoid being\n  // re-rendered on every animation frame.\n  !is.fun(Component) || Component.prototype.isReactComponent;\n  const forceUpdate = useForceUpdate();\n  const props = new AnimatedProps(() => {\n    const instance = instanceRef.current;\n\n    if (hasInstance && !instance) {\n      return; // The wrapped component forgot to forward its ref.\n    }\n\n    const didUpdate = instance ? applyAnimatedValues(instance, props.getValue(true)) : false; // Re-render the component when native updates fail.\n\n    if (didUpdate === false) {\n      forceUpdate();\n    }\n  });\n  const dependencies = new Set();\n  props.setValue(rawProps, {\n    dependencies\n  });\n  useIsomorphicLayoutEffect(() => {\n    each(dependencies, dep => dep.addChild(props));\n    return () => each(dependencies, dep => dep.removeChild(props));\n  });\n  return React.createElement(Component, Object.assign({}, getComponentProps(props.getValue()), {\n    ref: hasInstance && (value => {\n      instanceRef.current = updateRef(ref, value);\n    })\n  }));\n});\n\nfunction updateRef(ref, value) {\n  if (ref) {\n    if (is.fun(ref)) ref(value);else ref.current = value;\n  }\n\n  return value;\n}\n/**\r\n * Pass the given components to `withAnimated` and add the newly animated\r\n * components to `withAnimated` as properties.\r\n */\n\n\nconst extendAnimated = (withAnimated, components, lowercase) => {\n  components.forEach(Component => {\n    let key = getDisplayName(Component);\n\n    if (lowercase) {\n      key = key[0].toLowerCase() + key.slice(1);\n    }\n\n    withAnimated[key] = withAnimated(Component);\n  });\n  return withAnimated;\n};\n\nconst getDisplayName = arg => is.str(arg) ? arg : arg && is.str(arg.displayName) ? arg.displayName : is.fun(arg) && arg.name || null;\n\nexport { Animated, AnimatedArray, AnimatedObject, AnimatedProps, AnimatedString, AnimatedStyle, AnimatedValue, extendAnimated, getAnimated, getPayload, isAnimated, setAnimated, withAnimated };","map":{"version":3,"sources":["src/Animated.ts","src/AnimatedObject.ts","src/AnimatedStyle.ts","src/globals.ts","src/AnimatedValue.ts","src/AnimatedString.ts","src/AnimatedArray.ts","src/AnimatedProps.ts","src/withAnimated.tsx"],"names":["$node","Symbol","isAnimated","value","getAnimated","owner","setAnimated","defineHidden","getPayload","Animated","constructor","AnimatedObject","source","getValue","values","each","config","getFluidConfig","setValue","reset","node","_makePayload","payload","Array","_addToPayload","AnimatedStyle","style","transform","G","Globals","createAnimatedStyle","AnimatedValue","_value","is","create","Math","done","AnimatedString","from","to","createInterpolator","output","TypeError","AnimatedArray","newValue","_makeAnimated","isAnimatedString","AnimatedProps","update","props","onParentChange","type","cacheKey","withAnimated","Component","createAnimatedComponent","forwardRef","instanceRef","useRef","hasInstance","forceUpdate","useForceUpdate","instance","didUpdate","dependencies","useIsomorphicLayoutEffect","dep","ref","updateRef","extendAnimated","components","key","getDisplayName","arg"],"mappings":"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","sourcesContent":["import { defineHidden, each, getFluidConfig, Globals, is, createInterpolator, isAnimatedString, useForceUpdate, useIsomorphicLayoutEffect } from '@react-spring/shared';\nimport _extends from '@babel/runtime/helpers/esm/extends';\nimport { createAnimatedTransform, createAnimatedStyle, frameLoop, applyAnimatedValues, getComponentProps } from '@react-spring/shared/globals';\nimport React, { forwardRef, useRef } from 'react';\n\nconst $node = Symbol.for('Animated:node');\nconst isAnimated = value => !!value && value[$node] === value;\n/** Get the owner's `Animated` node. */\n\nconst getAnimated = owner => owner && owner[$node];\n/** Set the owner's `Animated` node. */\n\nconst setAnimated = (owner, node) => defineHidden(owner, $node, node);\n/** Get every `AnimatedValue` in the owner's `Animated` node. */\n\nconst getPayload = owner => owner && owner[$node] && owner[$node].getPayload();\nclass Animated {\n  constructor() {\n    setAnimated(this, this);\n  }\n  /** Get every `AnimatedValue` used by this node. */\n\n\n  getPayload() {\n    return this.payload || [];\n  }\n\n}\n/** The `AnimatedProps` class sets this before initializing */\n\nAnimated.context = null;\n\n/** An object containing `Animated` nodes */\n\nclass AnimatedObject extends Animated {\n  constructor(source = null) {\n    super();\n    this.setValue(source);\n  }\n\n  getValue(animated) {\n    if (!this.source) return null;\n    const values = {};\n    each(this.source, (source, key) => {\n      if (isAnimated(source)) {\n        values[key] = source.getValue(animated);\n      } else {\n        const config = getFluidConfig(source);\n\n        if (config) {\n          values[key] = config.get();\n        } else if (!animated) {\n          values[key] = source;\n        }\n      }\n    });\n    return values;\n  }\n  /** Replace the raw object data */\n\n\n  setValue(source) {\n    this.source = source;\n    this.payload = this._makePayload(source);\n  }\n\n  reset() {\n    if (this.payload) {\n      each(this.payload, node => node.reset());\n    }\n  }\n  /** Create a payload set. */\n\n\n  _makePayload(source) {\n    if (source) {\n      const payload = new Set();\n      each(source, this._addToPayload, payload);\n      return Array.from(payload);\n    }\n  }\n  /** Add to a payload set. */\n\n\n  _addToPayload(source) {\n    const config = getFluidConfig(source);\n\n    if (config && Animated.context) {\n      Animated.context.dependencies.add(source);\n    }\n\n    const payload = getPayload(source);\n\n    if (payload) {\n      each(payload, node => this.add(node));\n    }\n  }\n\n}\n\nclass AnimatedStyle extends AnimatedObject {\n  constructor(style) {\n    super(style || null);\n  }\n\n  setValue(style) {\n    super.setValue(style && style.transform && createAnimatedTransform ? _extends({}, style, {\n      transform: createAnimatedTransform(style.transform)\n    }) : style);\n  }\n\n}\n\nGlobals.assign({\n  createAnimatedStyle: style => new AnimatedStyle(style)\n});\n\n/** An animated number or a native attribute value */\n\nclass AnimatedValue extends Animated {\n  constructor(_value) {\n    super();\n    this._value = _value;\n    this.done = true;\n\n    if (is.num(this._value)) {\n      this.lastPosition = this._value;\n    }\n  }\n\n  static create(from, _to) {\n    return new AnimatedValue(from);\n  }\n\n  getPayload() {\n    return [this];\n  }\n\n  getValue() {\n    return this._value;\n  }\n  /**\r\n   * Set the current value and optionally round it.\r\n   *\r\n   * The `step` argument does nothing whenever it equals `undefined` or `0`.\r\n   * It works with fractions and whole numbers. The best use case is (probably)\r\n   * rounding to the pixel grid with a step of:\r\n   *\r\n   *      1 / window.devicePixelRatio\r\n   */\n\n\n  setValue(value, step) {\n    if (is.num(value)) {\n      this.lastPosition = value;\n\n      if (step) {\n        value = Math.round(value / step) * step;\n\n        if (this.done) {\n          this.lastPosition = value;\n        }\n      }\n    }\n\n    if (this._value === value) {\n      return false;\n    }\n\n    this._value = value;\n    return true;\n  }\n\n  reset() {\n    const {\n      done\n    } = this;\n    this.done = false;\n\n    if (is.num(this._value)) {\n      this.elapsedTime = 0;\n      this.lastPosition = this._value;\n      if (done) this.lastVelocity = null;\n      this.v0 = null;\n    }\n  }\n\n}\n\nclass AnimatedString extends AnimatedValue {\n  constructor(from, to) {\n    super(0);\n    this._string = null;\n    this._toString = createInterpolator({\n      output: [from, to]\n    });\n  }\n\n  static create(from, to = from) {\n    if (is.str(from) && is.str(to)) {\n      return new AnimatedString(from, to);\n    }\n\n    throw TypeError('Expected \"from\" and \"to\" to be strings');\n  }\n\n  getValue() {\n    let value = this._string;\n    return value == null ? this._string = this._toString(this._value) : value;\n  }\n\n  setValue(value) {\n    if (!is.num(value)) {\n      this._string = value;\n      this._value = 1;\n    } else if (super.setValue(value)) {\n      this._string = null;\n    } else {\n      return false;\n    }\n\n    return true;\n  }\n\n  reset(goal) {\n    if (goal) {\n      this._toString = createInterpolator({\n        output: [this.getValue(), goal]\n      });\n    }\n\n    this._value = 0;\n    super.reset();\n  }\n\n}\n\n/** An array of animated nodes */\n\nclass AnimatedArray extends AnimatedObject {\n  constructor(from, to) {\n    super(null);\n    super.setValue(this._makeAnimated(from, to));\n  }\n\n  static create(from, to) {\n    return new AnimatedArray(from, to);\n  }\n\n  getValue() {\n    return this.source.map(node => node.getValue());\n  }\n\n  setValue(newValue) {\n    const payload = this.getPayload(); // Reuse the payload when lengths are equal.\n\n    if (newValue && newValue.length == payload.length) {\n      each(payload, (node, i) => node.setValue(newValue[i]));\n    } else {\n      // Remake the payload when length changes.\n      this.source = this._makeAnimated(newValue);\n      this.payload = this._makePayload(this.source);\n    }\n  }\n  /** Convert the `from` and `to` values to an array of `Animated` nodes */\n\n\n  _makeAnimated(from, to = from) {\n    return from ? from.map((from, i) => (isAnimatedString(from) ? AnimatedString : AnimatedValue).create(from, to[i])) : [];\n  }\n\n}\n\nclass AnimatedProps extends AnimatedObject {\n  constructor(update) {\n    super(null);\n    this.update = update;\n    /** Equals true when an update is scheduled for \"end of frame\" */\n\n    this.dirty = false;\n  }\n\n  setValue(props, context) {\n    if (!props) return; // The constructor passes null.\n\n    if (context) {\n      Animated.context = context;\n    }\n\n    super.setValue(props.style && createAnimatedStyle ? _extends({}, props, {\n      style: createAnimatedStyle(props.style)\n    }) : props);\n    Animated.context = null;\n  }\n  /** @internal */\n\n\n  onParentChange({\n    type\n  }) {\n    if (!this.dirty && type === 'change') {\n      this.dirty = true;\n      frameLoop.onFrame(() => {\n        this.dirty = false;\n        this.update();\n      });\n    }\n  }\n\n}\n\nconst cacheKey = Symbol.for('AnimatedComponent');\nconst withAnimated = Component => is.str(Component) ? createAnimatedComponent(Component) : Component[cacheKey] || (Component[cacheKey] = createAnimatedComponent(Component));\n\nconst createAnimatedComponent = Component => forwardRef((rawProps, ref) => {\n  const instanceRef = useRef(null);\n  const hasInstance = // Function components must use \"forwardRef\" to avoid being\n  // re-rendered on every animation frame.\n  !is.fun(Component) || Component.prototype.isReactComponent;\n  const forceUpdate = useForceUpdate();\n  const props = new AnimatedProps(() => {\n    const instance = instanceRef.current;\n\n    if (hasInstance && !instance) {\n      return; // The wrapped component forgot to forward its ref.\n    }\n\n    const didUpdate = instance ? applyAnimatedValues(instance, props.getValue(true)) : false; // Re-render the component when native updates fail.\n\n    if (didUpdate === false) {\n      forceUpdate();\n    }\n  });\n  const dependencies = new Set();\n  props.setValue(rawProps, {\n    dependencies\n  });\n  useIsomorphicLayoutEffect(() => {\n    each(dependencies, dep => dep.addChild(props));\n    return () => each(dependencies, dep => dep.removeChild(props));\n  });\n  return React.createElement(Component, Object.assign({}, getComponentProps(props.getValue()), {\n    ref: hasInstance && (value => {\n      instanceRef.current = updateRef(ref, value);\n    })\n  }));\n});\n\nfunction updateRef(ref, value) {\n  if (ref) {\n    if (is.fun(ref)) ref(value);else ref.current = value;\n  }\n\n  return value;\n}\n/**\r\n * Pass the given components to `withAnimated` and add the newly animated\r\n * components to `withAnimated` as properties.\r\n */\n\n\nconst extendAnimated = (withAnimated, components, lowercase) => {\n  components.forEach(Component => {\n    let key = getDisplayName(Component);\n\n    if (lowercase) {\n      key = key[0].toLowerCase() + key.slice(1);\n    }\n\n    withAnimated[key] = withAnimated(Component);\n  });\n  return withAnimated;\n};\n\nconst getDisplayName = arg => is.str(arg) ? arg : arg && is.str(arg.displayName) ? arg.displayName : is.fun(arg) && arg.name || null;\n\nexport { Animated, AnimatedArray, AnimatedObject, AnimatedProps, AnimatedString, AnimatedStyle, AnimatedValue, extendAnimated, getAnimated, getPayload, isAnimated, setAnimated, withAnimated };\n//# sourceMappingURL=index.js.map\n"]},"metadata":{},"sourceType":"module"}