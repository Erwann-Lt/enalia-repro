{"ast":null,"code":"import { useIsomorphicLayoutEffect, each, is, toArray, FluidValue, getFluidConfig, isAnimatedString, isEqual, noop, usePrev, useOnce, useForceUpdate, createInterpolator, Globals } from '@react-spring/shared';\nexport { FrameLoop, Globals, createInterpolator } from '@react-spring/shared';\nimport React, { useMemo as useMemo$1, useImperativeHandle, useRef } from 'react';\nimport _extends from '@babel/runtime/helpers/esm/extends';\nimport { to as to$1, frameLoop, createStringInterpolator, now, skipAnimation, batchedUpdates } from '@react-spring/shared/globals';\nimport { useMemoOne } from 'use-memo-one';\nimport { getAnimated, AnimatedValue, getPayload, setAnimated, AnimatedString, AnimatedArray } from '@react-spring/animated';\nimport { deprecateInterpolate } from '@react-spring/shared/deprecations';\nimport _objectWithoutPropertiesLoose from '@babel/runtime/helpers/esm/objectWithoutPropertiesLoose';\nimport { createStringInterpolator as createStringInterpolator$1 } from '@react-spring/shared/stringInterpolation';\n/** API\n *  useChain(references, timeSteps, timeFrame)\n */\n\nfunction useChain(refs, timeSteps, timeFrame = 1000) {\n  useIsomorphicLayoutEffect(() => {\n    if (timeSteps) {\n      let prevDelay = 0;\n      each(refs, (ref, i) => {\n        if (!ref.current) return;\n        const {\n          controllers\n        } = ref.current;\n\n        if (controllers.length) {\n          let delay = timeFrame * timeSteps[i]; // Use the previous delay if none exists.\n\n          if (isNaN(delay)) delay = prevDelay;else prevDelay = delay;\n          each(controllers, ctrl => {\n            each(ctrl.queue, props => {\n              props.delay = delay + (props.delay || 0);\n            });\n            ctrl.start();\n          });\n        }\n      });\n    } else {\n      let p = Promise.resolve();\n      each(refs, ref => {\n        const {\n          controllers,\n          start\n        } = ref.current || {};\n\n        if (controllers && controllers.length) {\n          // Take the queue of each controller\n          const updates = controllers.map(ctrl => {\n            const q = ctrl.queue;\n            ctrl.queue = [];\n            return q;\n          }); // Apply the queue when the previous ref stops animating\n\n          p = p.then(() => {\n            each(controllers, (ctrl, i) => ctrl.queue.push(...updates[i]));\n            return start();\n          });\n        }\n      });\n    }\n  });\n}\n\nconst useMemo = (create, deps) => useMemoOne(create, deps || [{}]);\n\nfunction callProp(value, ...args) {\n  return is.fun(value) ? value(...args) : value;\n}\n/** Try to coerce the given value into a boolean using the given key */\n\n\nconst matchProp = (value, key) => value === true || !!(key && value && (is.fun(value) ? value(key) : toArray(value).includes(key)));\n\nconst getProps = (props, i, arg) => is.fun(props) ? props(i, arg) : is.arr(props) ? props[i] : _extends({}, props);\n/** These props can have default values */\n\n\nconst DEFAULT_PROPS = ['config', 'immediate', 'onAnimate', 'onStart', 'onChange', 'onRest'];\nconst RESERVED_PROPS = {\n  children: 1,\n  config: 1,\n  from: 1,\n  to: 1,\n  ref: 1,\n  reset: 1,\n  cancel: 1,\n  reverse: 1,\n  immediate: 1,\n  default: 1,\n  delay: 1,\n  lazy: 1,\n  items: 1,\n  trail: 1,\n  sort: 1,\n  expires: 1,\n  initial: 1,\n  enter: 1,\n  leave: 1,\n  update: 1,\n  onAnimate: 1,\n  onStart: 1,\n  onRest: 1,\n  onChange: 1,\n  onFrame: 1\n};\n/**\r\n * Extract any properties whose keys are *not* reserved for customizing your\r\n * animations. All hooks use this function, which means `useTransition` props\r\n * are reserved for `useSpring` calls, etc.\r\n */\n\nfunction getForwardProps(props) {\n  const forward = {};\n  each(props, (value, prop) => {\n    if (!RESERVED_PROPS[prop]) {\n      forward[prop] = value;\n    }\n  });\n  return forward;\n}\n\nfunction interpolateTo(props) {\n  const to = getForwardProps(props);\n  const out = {\n    to\n  };\n  each(props, (val, key) => key in to || (out[key] = val));\n  return out;\n}\n/**\r\n * Start an async chain or an async script.\r\n *\r\n * You should always wrap `runAsync` calls with `scheduleProps` so that\r\n * you have access to `RunAsyncProps` instead of the usual `SpringProps`.\r\n *\r\n * The `T` parameter can be a set of animated values (as an object type)\r\n * or a primitive type for a single animated value.\r\n */\n\n\nasync function runAsync(to, props, state, getValue, getPaused, update, stop) {\n  if (props.cancel) {\n    state.asyncTo = undefined;\n    return {\n      value: getValue(),\n      cancelled: true\n    };\n  } // Wait for the previous async animation to be cancelled.\n  else if (props.reset) {\n    await state.promise;\n  } // Async animations are only replaced when \"props.to\" changes\n  // or when \"props.reset\" equals true.\n  else if (to === state.asyncTo) {\n    return state.promise;\n  }\n\n  state.asyncTo = to;\n  return state.promise = (async () => {\n    const {\n      asyncId\n    } = props;\n    const cancelToken = Symbol.for('cancel');\n\n    const isCancelled = () => to !== state.asyncTo || asyncId <= (state.cancelId || 0);\n\n    const defaultProps = {};\n    each(DEFAULT_PROPS, prop => {\n      if (prop == 'onRest') return;\n\n      if (/function|object/.test(typeof props[prop])) {\n        defaultProps[prop] = props[prop];\n      }\n    });\n\n    const animate = (arg1, arg2) => {\n      if (isCancelled()) {\n        throw cancelToken;\n      }\n\n      const props = is.obj(arg1) ? _extends({}, arg1) : _extends({}, arg2, {\n        to: arg1\n      });\n      each(defaultProps, (value, prop) => {\n        if (is.und(props[prop])) {\n          props[prop] = value;\n        }\n      });\n      const parentTo = state.asyncTo;\n      return update(props).then(async result => {\n        if (state.asyncTo == null) {\n          state.asyncTo = parentTo;\n        }\n\n        if (isCancelled()) {\n          throw cancelToken;\n        }\n\n        if (getPaused()) {\n          await new Promise(resolve => {\n            state.unpause = resolve;\n          });\n          state.unpause = undefined;\n        }\n\n        return result;\n      });\n    };\n\n    let result;\n\n    try {\n      // Async sequence\n      if (is.arr(to)) {\n        for (const props of to) {\n          await animate(props);\n        }\n      } // Async script\n      else if (is.fun(to)) {\n        await to(animate, stop);\n      }\n\n      result = {\n        value: getValue(),\n        finished: true\n      };\n    } catch (err) {\n      if (err !== cancelToken) {\n        throw err;\n      }\n\n      result = {\n        value: getValue(),\n        cancelled: true\n      };\n    } finally {\n      state.promise = undefined;\n\n      if (to == state.asyncTo) {\n        state.asyncTo = undefined;\n      }\n    }\n\n    if (props.onRest) {\n      props.onRest(result);\n    }\n\n    return result;\n  })();\n} //\n// scheduleProps(props, state, action)\n//\n\n/**\r\n * Pass props to your action when any delay is finished and the\r\n * props weren't cancelled before then.\r\n */\n\n\nfunction scheduleProps(asyncId, {\n  key,\n  props,\n  state,\n  action\n}) {\n  return new Promise((resolve, reject) => {\n    let {\n      delay,\n      cancel,\n      reset\n    } = props;\n\n    if (is.num(delay) && delay > 0) {\n      setTimeout(run, delay);\n    } else run();\n\n    function run() {\n      // Might be cancelled during delay.\n      if (asyncId <= (state.cancelId || 0)) {\n        cancel = true;\n      } else {\n        cancel = matchProp(cancel, key);\n\n        if (cancel) {\n          state.cancelId = asyncId;\n        }\n      }\n\n      reset = !cancel && matchProp(reset, key);\n\n      try {\n        action(_extends({}, props, {\n          asyncId,\n          cancel,\n          reset\n        }), resolve);\n      } catch (err) {\n        reject(err);\n      }\n    }\n  });\n} // The `mass` prop defaults to 1\n\n\nconst config = {\n  default: {\n    tension: 170,\n    friction: 26\n  },\n  gentle: {\n    tension: 120,\n    friction: 14\n  },\n  wobbly: {\n    tension: 180,\n    friction: 12\n  },\n  stiff: {\n    tension: 210,\n    friction: 20\n  },\n  slow: {\n    tension: 280,\n    friction: 60\n  },\n  molasses: {\n    tension: 280,\n    friction: 120\n  }\n};\nconst none = undefined;\nconst emptyArray = [];\nconst defaultConfig = config.default;\n/** Accelerate until halfway, then decelerate */\n\nconst linear = t => t;\n/** An animation being executed by the frameloop */\n\n\nclass Animation {\n  constructor() {\n    this.changed = false;\n    this.values = emptyArray;\n    this.to = none;\n    this.toValues = null;\n    this.from = none;\n    this.fromValues = emptyArray;\n    this.config = new AnimationConfig();\n    this.reverse = false;\n    this.immediate = false;\n    this.onStart = none;\n    this.onChange = none;\n    this.onRest = none;\n  }\n\n}\n\nclass AnimationConfig {\n  constructor() {\n    /**\r\n     * With higher tension, the spring will resist bouncing and try harder to stop at its end value.\r\n     *\r\n     * When tension is zero, no animation occurs.\r\n     */\n    this.tension = defaultConfig.tension;\n    /**\r\n     * The damping ratio coefficient, or just the damping ratio when `speed` is defined.\r\n     *\r\n     * When `speed` is defined, this value should be between 0 and 1.\r\n     *\r\n     * Higher friction means the spring will slow down faster.\r\n     */\n\n    this.friction = defaultConfig.friction;\n    /**\r\n     * The natural frequency (in seconds), which dictates the number of bounces\r\n     * per second when no damping exists.\r\n     *\r\n     * When defined, `tension` is derived from this, and `friction` is derived\r\n     * from `tension` and `damping`.\r\n     */\n\n    this.frequency = none;\n    /**\r\n     * The damping ratio, which dictates how the spring slows down.\r\n     *\r\n     * Set to `0` to never slow down. Set to `1` to slow down without bouncing.\r\n     * Between `0` and `1` is for you to explore.\r\n     *\r\n     * Only works when `frequency` is defined.\r\n     *\r\n     * Defaults to 1\r\n     */\n\n    this.damping = 1;\n    /**\r\n     * Higher mass means more friction is required to slow down.\r\n     *\r\n     * Defaults to 1, which works fine most of the time.\r\n     */\n\n    this.mass = 1;\n    /**\r\n     * The initial velocity of one or more values.\r\n     */\n\n    this.velocity = 0;\n    /**\r\n     * The smallest velocity before the animation is considered \"not moving\".\r\n     *\r\n     * When undefined, `precision` is used instead.\r\n     */\n\n    this.restVelocity = none;\n    /**\r\n     * The smallest distance from a value before that distance is essentially zero.\r\n     *\r\n     * This helps in deciding when a spring is \"at rest\". The spring must be within\r\n     * this distance from its final value, and its velocity must be lower than this\r\n     * value too (unless `restVelocity` is defined).\r\n     */\n\n    this.precision = none;\n    /**\r\n     * For `duration` animations only. Note: The `duration` is not affected\r\n     * by this property.\r\n     *\r\n     * Defaults to `0`, which means \"start from the beginning\".\r\n     *\r\n     * Setting to `1+` makes an immediate animation.\r\n     *\r\n     * Setting to `0.5` means \"start from the middle of the easing function\".\r\n     *\r\n     * Any number `>= 0` and `<= 1` makes sense here.\r\n     */\n\n    this.progress = none;\n    /**\r\n     * Animation length in number of milliseconds.\r\n     */\n\n    this.duration = none;\n    /**\r\n     * The animation curve. Only used when `duration` is defined.\r\n     *\r\n     * Defaults to quadratic ease-in-out.\r\n     */\n\n    this.easing = linear;\n    /**\r\n     * Avoid overshooting by ending abruptly at the goal value.\r\n     */\n\n    this.clamp = false;\n    /**\r\n     * When above zero, the spring will bounce instead of overshooting when\r\n     * exceeding its goal value. Its velocity is multiplied by `-1 + bounce`\r\n     * whenever its current value equals or exceeds its goal. For example,\r\n     * setting `bounce` to `0.5` chops the velocity in half on each bounce,\r\n     * in addition to any friction.\r\n     */\n\n    this.bounce = none;\n    /**\r\n     * \"Decay animations\" decelerate without an explicit goal value.\r\n     * Useful for scrolling animations.\r\n     *\r\n     * Use `true` for the default exponential decay factor (`0.998`).\r\n     *\r\n     * When a `number` between `0` and `1` is given, a lower number makes the\r\n     * animation slow down faster. And setting to `1` would make an unending\r\n     * animation.\r\n     */\n\n    this.decay = none;\n    /**\r\n     * While animating, round to the nearest multiple of this number.\r\n     * The `from` and `to` values are never rounded, as well as any value\r\n     * passed to the `set` method of an animated value.\r\n     */\n\n    this.round = none;\n  }\n  /* might be reintroduced later */\n\n  /**\r\n   * @internal\r\n   * The angular frequency in rad/ms\r\n   */\n  // w0 = 0\n\n  /**\r\n   * Partially overwrite the existing config.\r\n   */\n\n\n  merge(config) {\n    const {\n      mass,\n      frequency,\n      damping\n    } = Object.assign(this, config); // Derive \"tension\" and \"friction\" from \"frequency\" and \"damping\".\n\n    if (!is.und(frequency)) {\n      this.tension = Math.pow(frequency, 2) * mass;\n      this.friction = damping * Math.sqrt(this.tension * mass) / 0.5;\n    }\n    /* might be reintroduced later */\n    // Cache the angular frequency in rad/ms\n    // this.w0 = Math.sqrt(this.tension / mass) / 1000\n\n  }\n\n}\n\nconst isFrameValue = value => value instanceof FrameValue;\n\nlet nextId = 1;\n/**\r\n * A kind of `FluidValue` that manages an `AnimatedValue` node.\r\n *\r\n * Its underlying value can be accessed and even observed.\r\n */\n\nclass FrameValue extends FluidValue {\n  constructor() {\n    super(...arguments);\n    this.id = nextId++;\n    this._priority = 0;\n    this._children = new Set();\n  }\n\n  get priority() {\n    return this._priority;\n  }\n\n  set priority(priority) {\n    if (this._priority != priority) {\n      this._priority = priority;\n\n      this._onPriorityChange(priority);\n    }\n  }\n\n  get velocity() {\n    const node = getAnimated(this);\n    return node instanceof AnimatedValue ? node.lastVelocity || 0 : node.getPayload().map(node => node.lastVelocity || 0);\n  }\n  /** Get the current value */\n\n\n  get() {\n    const node = getAnimated(this);\n    return node && node.getValue();\n  }\n  /** Create a spring that maps our value to another value */\n\n\n  to(...args) {\n    return to$1(this, args);\n  }\n  /** @deprecated Use the `to` method instead. */\n\n\n  interpolate(...args) {\n    deprecateInterpolate();\n    return to$1(this, args);\n  }\n  /** @internal */\n\n\n  addChild(child) {\n    if (!this._children.size) this._attach();\n\n    this._children.add(child);\n  }\n  /** @internal */\n\n\n  removeChild(child) {\n    this._children.delete(child);\n\n    if (!this._children.size) this._detach();\n  }\n  /** @internal */\n\n\n  onParentChange(event) {\n    if (event.type == 'reset') {\n      this._reset(event.goal);\n    } else if (event.type == 'start') {\n      this._start();\n    }\n  }\n  /** Called when the first child is added. */\n\n\n  _attach() {}\n  /** Called when the last child is removed. */\n\n\n  _detach() {}\n  /** Reset the animation state of this value and every descendant */\n\n\n  _reset(goal) {\n    this._emit({\n      type: 'reset',\n      parent: this,\n      goal\n    });\n  }\n  /** Enter the frameloop if possible */\n\n\n  _start() {\n    this._emit({\n      type: 'start',\n      parent: this\n    });\n  }\n  /** Notify observers of a change to our value */\n\n\n  _onChange(value, idle = false) {\n    this._emit({\n      type: 'change',\n      parent: this,\n      value,\n      idle\n    });\n  }\n  /** Notify observers of a change to our priority */\n\n\n  _onPriorityChange(priority) {\n    if (!this.idle) {\n      frameLoop.start(this);\n    }\n\n    this._emit({\n      type: 'priority',\n      parent: this,\n      priority\n    });\n  }\n\n  _emit(event) {\n    // Clone \"_children\" so it can be safely mutated inside the loop.\n    each(Array.from(this._children), child => {\n      child.onParentChange(event);\n    });\n  }\n\n}\n/** The spring cannot be animated */\n\n\nconst DISPOSED = 'DISPOSED';\n/** The spring has not animated yet */\n\nconst CREATED = 'CREATED';\n/** The spring has animated before */\n\nconst IDLE = 'IDLE';\n/** The spring is frozen in time */\n\nconst PAUSED = 'PAUSED';\n/** The spring is animating */\n\nconst ACTIVE = 'ACTIVE';\n/** An opaque animatable value */\n\nclass SpringValue extends FrameValue {\n  constructor(arg1, arg2) {\n    super();\n    /** The animation state */\n\n    this.animation = new Animation();\n    /** The lifecycle phase of this spring */\n\n    this._phase = CREATED;\n    /** The state for `runAsync` calls */\n\n    this._state = {};\n    /** The last time each prop changed */\n\n    this._timestamps = {};\n    /** Some props have customizable default values */\n\n    this._defaultProps = {};\n    /** Cancel any update from before this timestamp */\n\n    this._lastAsyncId = 0;\n\n    if (arguments.length) {\n      this.start(is.obj(arg1) ? arg1 : _extends({}, arg2, {\n        from: arg1\n      }));\n    }\n  }\n\n  get idle() {\n    return !this.is(ACTIVE);\n  }\n  /** Advance the current animation by a number of milliseconds */\n\n\n  advance(dt) {\n    let idle = true;\n    let changed = false;\n    const anim = this.animation;\n    const payload = getPayload(anim.to);\n    let {\n      toValues\n    } = anim;\n\n    if (!payload) {\n      const toConfig = getFluidConfig(anim.to);\n      if (toConfig) toValues = toArray(toConfig.get());\n    }\n\n    anim.values.forEach((node, i) => {\n      if (node.done) return; // The \"anim.toValues\" array must exist when no parent exists.\n\n      let to = payload ? payload[i].lastPosition : toValues[i]; // Parent springs must finish before their children can.\n\n      const canFinish = !payload || payload[i].done; // Jump to end value for immediate animations.\n\n      if (anim.immediate) {\n        node.done = canFinish || (idle = false);\n\n        if (node.setValue(to)) {\n          changed = true;\n        }\n\n        return;\n      }\n\n      const {\n        config\n      } = anim; // Loose springs never move.\n\n      if (config.tension == 0) {\n        node.done = true;\n        return;\n      }\n\n      const elapsed = node.elapsedTime += dt;\n      const from = anim.fromValues[i];\n      const v0 = node.v0 != null ? node.v0 : node.v0 = is.arr(config.velocity) ? config.velocity[i] : config.velocity;\n      let position = node.lastPosition;\n      let velocity;\n      let finished; // Duration easing\n\n      if (!is.und(config.duration)) {\n        let p = config.progress || 0;\n        if (config.duration <= 0) p = 1;else p += (1 - p) * Math.min(1, elapsed / config.duration);\n        position = from + config.easing(p) * (to - from);\n        velocity = (position - node.lastPosition) / dt;\n        finished = p == 1;\n      } // Decay easing\n      else if (config.decay) {\n        const decay = config.decay === true ? 0.998 : config.decay;\n        const e = Math.exp(-(1 - decay) * elapsed);\n        position = from + v0 / (1 - decay) * (1 - e); // derivative of position\n\n        velocity = v0 * e;\n        finished = Math.abs(node.lastPosition - position) < 0.1;\n        if (finished) to = position;\n      } // Spring easing\n      else {\n        velocity = node.lastVelocity == null ? v0 : node.lastVelocity;\n        /** The smallest distance from a value before being treated like said value. */\n\n        const precision = config.precision || (from == to ? 0.005 : Math.min(1, Math.abs(to - from) * 0.001));\n        /** The velocity at which movement is essentially none */\n\n        const restVelocity = config.restVelocity || precision; // Bouncing is opt-in (not to be confused with overshooting)\n\n        const bounceFactor = config.clamp ? 0 : config.bounce;\n        const canBounce = !is.und(bounceFactor);\n        /** When `true`, the value is increasing over time */\n\n        const isGrowing = from == to ? node.v0 > 0 : from < to;\n        /** When `true`, the velocity is considered moving */\n\n        let isMoving;\n        /** When `true`, the velocity is being deflected or clamped */\n\n        let isBouncing = false; //const step = 0.05 / config.w0\n\n        const step = 1; // 1ms\n\n        const numSteps = Math.ceil(dt / step);\n\n        for (let n = 0; n < numSteps; ++n) {\n          isMoving = Math.abs(velocity) > restVelocity;\n\n          if (!isMoving) {\n            finished = Math.abs(to - position) <= precision;\n\n            if (finished) {\n              break;\n            }\n          }\n\n          if (canBounce) {\n            isBouncing = position == to || position > to == isGrowing; // Invert the velocity with a magnitude, or clamp it.\n\n            if (isBouncing) {\n              velocity = -velocity * bounceFactor;\n              position = to;\n            }\n          }\n\n          const springForce = -config.tension * 0.000001 * (position - to);\n          const dampingForce = -config.friction * 0.001 * velocity;\n          const acceleration = (springForce + dampingForce) / config.mass; // pt/ms^2\n\n          velocity = velocity + acceleration * step; // pt/ms\n\n          position = position + velocity * step;\n        }\n      }\n\n      if (Number.isNaN(position)) {\n        console.warn(`Got NaN while animating:`, this);\n        return this.finish();\n      }\n\n      if (finished && canFinish) {\n        node.done = true;\n      } else {\n        idle = false;\n      }\n\n      node.lastVelocity = velocity;\n\n      if (node.setValue(position, config.round)) {\n        changed = true;\n      }\n    });\n\n    if (idle) {\n      this.finish();\n    } else if (changed) {\n      this._onChange(this.get());\n    }\n\n    return idle;\n  }\n  /** Check the current phase */\n\n\n  is(phase) {\n    return this._phase == phase;\n  }\n  /** Set the current value, while stopping the current animation */\n\n\n  set(value) {\n    if (this._set(value) && this.idle) {\n      // Since \"_stop\" calls \"_onChange\" only when not idle, we need this.\n      this._onChange(this.get(), true);\n    }\n\n    this._stop();\n\n    return this;\n  }\n  /**\r\n   * Freeze the active animation in time.\r\n   * This does nothing when not animating.\r\n   *\r\n   * Call `start` to unpause.\r\n   */\n\n\n  pause() {\n    checkDisposed(this, 'pause');\n    this._phase = PAUSED;\n  }\n  /**\r\n   * Skip to the end of the current animation.\r\n   *\r\n   * All `onRest` callbacks are passed `{finished: true}`\r\n   */\n\n\n  finish(to) {\n    if (!this.idle) {\n      const anim = this.animation; // Decay animations have an implicit goal.\n\n      if (!anim.config.decay && is.und(to)) {\n        to = anim.to;\n      } // Set the value if we can.\n\n\n      if (!is.und(to)) {\n        this._set(to);\n      } // Exit the frameloop.\n\n\n      this._stop(true);\n    }\n\n    return this;\n  }\n  /** Push props into the pending queue. */\n\n\n  update(props) {\n    checkDisposed(this, 'update'); // Ensure the initial value can be accessed by animated components.\n\n    this.setNodeWithProps(props);\n    const queue = this.queue || (this.queue = []);\n    queue.push(props);\n    return this;\n  }\n\n  async start(to, arg2) {\n    checkDisposed(this, 'start'); // Unpause if possible.\n\n    if (this.is(PAUSED)) {\n      this._start();\n\n      if (this._state.asyncTo) {\n        this._state.unpause();\n      }\n    }\n\n    let queue;\n\n    if (!is.und(to)) {\n      queue = [is.obj(to) ? to : _extends({}, arg2, {\n        to\n      })];\n    } else {\n      queue = this.queue || [];\n      this.queue = [];\n    }\n\n    await Promise.all(queue.map(props => this._animate(props)));\n    return {\n      finished: true,\n      value: this.get(),\n      spring: this\n    };\n  }\n  /**\r\n   * Stop the current animation, and cancel any delayed updates.\r\n   */\n\n\n  stop() {\n    if (!this.is(DISPOSED)) {\n      this._state.cancelId = this._lastAsyncId;\n\n      this._to(this.get());\n\n      this._stop();\n    }\n\n    return this;\n  }\n  /** Restart the animation. */\n\n\n  reset() {\n    this._animate({\n      reset: true\n    });\n  }\n  /** Prevent future animations, and stop the current animation */\n\n\n  dispose() {\n    if (!this.is(DISPOSED)) {\n      if (this.animation) {\n        // Prevent \"onRest\" calls when disposed.\n        this.animation.onRest = undefined;\n      }\n\n      this.stop();\n      this._phase = DISPOSED;\n    }\n  }\n  /** @internal */\n\n\n  onParentChange(event) {\n    super.onParentChange(event);\n\n    if (this.idle && event.type == 'change') {\n      const anim = this.animation;\n\n      if (!anim.immediate) {\n        anim.fromValues = anim.values.map(node => node.lastPosition);\n      } // Enter the frameloop when a parent changes.\n\n\n      this._start();\n    } else if (event.type == 'priority') {\n      this.priority = event.priority + 1;\n    }\n  }\n  /**\r\n   * Analyze the given `value` to determine which data type is being animated.\r\n   * Then, create an `Animated` node for that data type and make it our `node`.\r\n   */\n\n\n  _ensureAnimated(value) {\n    if (value != null) {\n      const nodeType = this._getNodeType(value);\n\n      setAnimated(this, nodeType.create(computeGoal(value)));\n    }\n  }\n  /**\r\n   * @internal\r\n   * Analyze the given `props` to determine which data type is being animated.\r\n   * Then, create an `Animated` node for that data type and make it our `node`.\r\n   * If we already have a `node`, do nothing but return the `{from, to}` range.\r\n   */\n\n\n  setNodeWithProps(props) {\n    const range = this._getRange(props);\n\n    if (!getAnimated(this)) {\n      this._ensureAnimated(range.from != null ? range.from : range.to);\n    }\n\n    return range;\n  }\n  /** Return the `Animated` node constructor for a given value */\n\n\n  _getNodeType(value) {\n    const parentNode = getAnimated(value);\n\n    if (parentNode) {\n      const parentType = parentNode.constructor;\n      return parentType == AnimatedString ? AnimatedValue : parentType;\n    }\n\n    return is.arr(value) ? AnimatedArray : isAnimatedString(value) ? AnimatedString : AnimatedValue;\n  }\n  /** Pluck the `to` and `from` props */\n\n\n  _getRange(props) {\n    const {\n      to,\n      from\n    } = props;\n    const key = this.key || '';\n    return {\n      to: !is.obj(to) || getFluidConfig(to) ? to : to[key],\n      from: !is.obj(from) || getFluidConfig(from) ? from : from[key]\n    };\n  }\n  /** Schedule an animation to run after an optional delay */\n\n\n  _animate(props) {\n    // Ensure the initial value can be accessed by animated components.\n    const range = this.setNodeWithProps(props);\n    const state = this._state;\n    const timestamp = now();\n    return scheduleProps(++this._lastAsyncId, {\n      key: this.key,\n      props,\n      state,\n      action: (props, resolve) => {\n        const {\n          to\n        } = props;\n\n        if (is.arr(to) || is.fun(to)) {\n          resolve(runAsync(to, props, state, () => this.get(), () => this.is(PAUSED), this.start.bind(this), this.stop.bind(this)));\n        } else if (props.cancel) {\n          this.stop();\n          resolve({\n            value: this.get(),\n            cancelled: true\n          });\n        } else {\n          this._update(range, props, timestamp, resolve);\n        }\n      }\n    });\n  }\n  /** Update the current animation */\n\n\n  _update({\n    to,\n    from\n  }, props, timestamp, resolve) {\n    const defaultProps = this._defaultProps;\n    /** Get the value of a prop, or its default value */\n\n    const get = prop => !is.und(props[prop]) ? props[prop] : defaultProps[prop];\n\n    const onAnimate = get('onAnimate');\n\n    if (onAnimate) {\n      onAnimate(props, this);\n    } // Cast from a partial type.\n\n\n    const anim = this.animation;\n    const timestamps = this._timestamps;\n    /** Return true if our prop can be used. This only affects delayed props. */\n\n    const diff = prop => {\n      if (timestamp >= (timestamps[prop] || 0)) {\n        timestamps[prop] = timestamp;\n        return true;\n      }\n\n      return false;\n    };\n\n    const {\n      to: prevTo,\n      from: prevFrom\n    } = anim; // The \"reverse\" prop only affects one update.\n\n    if (props.reverse) [to, from] = [from, to];\n\n    if (!is.und(to) && diff('to')) {\n      this._to(to);\n    } else {\n      to = prevTo;\n    }\n\n    if (!is.und(from) && diff('from')) {\n      anim.from = from;\n    } else {\n      from = anim.from;\n    }\n\n    const toConfig = getFluidConfig(to);\n    const fromConfig = getFluidConfig(from);\n\n    if (fromConfig) {\n      from = fromConfig.get();\n    }\n\n    const reset = props.reset && !is.und(from);\n    const changed = !is.und(to) && !isEqual(to, prevTo);\n    /** The current value */\n\n    let value = reset ? from : this.get();\n\n    if (is.und(from)) {\n      from = value;\n    }\n    /** When true, this spring must be in the frameloop. */\n\n\n    let started = !!toConfig || (changed || reset) && !isEqual(value, to);\n    /** The initial velocity before this `animate` call. */\n\n    const lastVelocity = anim.config ? anim.config.velocity : 0; // The \"config\" prop either overwrites or merges into the existing config.\n\n    if (!anim.config || props.config || started) {\n      const config = _extends({}, callProp(defaultProps.config, this.key), callProp(props.config, this.key));\n\n      if (!canMergeConfigs(config, anim.config)) {\n        anim.config = new AnimationConfig();\n      }\n\n      anim.config.merge(config);\n    }\n\n    const {\n      config\n    } = anim; // Always start animations with velocity.\n\n    if (!started && (config.decay || !is.und(to))) {\n      started = !isEqual(config.velocity, lastVelocity);\n    } // Reset our internal `Animated` node if starting.\n\n\n    let node = getAnimated(this);\n    let nodeType;\n\n    if (changed) {\n      nodeType = this._getNodeType(to);\n\n      if (nodeType !== node.constructor) {\n        throw Error(`Cannot animate to the given \"to\" prop, because the current value has a different type`);\n      }\n    } else {\n      nodeType = node.constructor;\n    } // The final value of our animation, excluding the \"to\" value.\n    // Our goal value is dynamic when \"toConfig\" exists.\n\n\n    let goal = toConfig ? null : computeGoal(to);\n\n    if (nodeType == AnimatedString) {\n      from = 0;\n      goal = 1;\n    } // Ensure the current value equals the \"from\" value when reset\n    // and when the \"from\" value is updated before the first animation.\n\n\n    if (reset || this.is(CREATED) && !is.und(anim.from) && !isEqual(anim.from, prevFrom)) {\n      node.setValue(value = from);\n    } // Event props are replaced on every update.\n\n\n    anim.onStart = get('onStart');\n    anim.onChange = get('onChange'); // Update the default props.\n\n    if (props.default) {\n      each(DEFAULT_PROPS, prop => {\n        // Default props can only be null, an object, or a function.\n        if (/function|object/.test(typeof props[prop])) {\n          defaultProps[prop] = props[prop];\n        }\n      });\n    }\n\n    if (!started) {\n      // Resolve the \"animate\" promise.\n      return resolve({\n        value,\n        spring: this,\n        finished: true\n      });\n    }\n\n    anim.values = node.getPayload();\n    anim.toValues = toConfig ? null : toArray(goal);\n    anim.immediate = // Sometimes the value is not animatable.\n    !(toConfig || is.num(goal) || is.arr(goal)) || !!matchProp(get('immediate'), this.key); // Avoid calling this before \"immediate\" is set\n\n    this._reset();\n\n    const onRestQueue = anim.onRest; // The \"onRest\" prop is always first in the queue.\n\n    anim.onRest = [get('onRest') || noop, resolve]; // Resolve the promise for unfinished animations.\n\n    if (onRestQueue && onRestQueue.length > 1) {\n      const result = {\n        value,\n        spring: this,\n        cancelled: true\n      }; // Skip the \"onRest\" prop, as the animation is still active.\n\n      for (let i = 1; i < onRestQueue.length; i++) {\n        onRestQueue[i](result);\n      }\n    }\n\n    this._start();\n  }\n  /** Update the `animation.to` value, which might be a `FluidValue` */\n\n\n  _to(value) {\n    const anim = this.animation;\n    if (value === anim.to) return;\n    let config = getFluidConfig(anim.to);\n\n    if (config) {\n      config.removeChild(this);\n    }\n\n    anim.to = value;\n    let priority = 0;\n\n    if (config = getFluidConfig(value)) {\n      config.addChild(this);\n\n      if (isFrameValue(value)) {\n        priority = (value.priority || 0) + 1;\n      }\n    }\n\n    this.priority = priority;\n  }\n  /** Set the current value and our `node` if necessary. The `_onChange` method is *not* called. */\n\n\n  _set(value) {\n    const config = getFluidConfig(value);\n\n    if (config) {\n      value = config.get();\n    }\n\n    const node = getAnimated(this);\n\n    if (node) {\n      if (isEqual(value, node.getValue())) {\n        return false;\n      }\n\n      node.setValue(value);\n    } else {\n      this._ensureAnimated(value);\n    }\n\n    return true;\n  }\n  /** Notify change observers */\n\n\n  _onChange(value, idle = false) {\n    const anim = this.animation;\n\n    if (!anim.changed && !idle) {\n      anim.changed = true; // The \"onStart\" prop is called on the first change after entering the\n      // frameloop, but never for immediate animations.\n\n      if (anim.onStart) {\n        anim.onStart(this);\n      }\n    }\n\n    if (anim.onChange) {\n      anim.onChange(value, this);\n    }\n\n    super._onChange(value, idle);\n  }\n  /** Reset our node, and the nodes of every descendant spring */\n\n\n  _reset(goal) {\n    const anim = this.animation;\n\n    if (is.und(goal)) {\n      goal = computeGoal(anim.to);\n    }\n\n    getAnimated(this).reset(goal);\n\n    super._reset(goal);\n\n    if (!anim.immediate) {\n      anim.fromValues = anim.values.map(node => node.lastPosition);\n    }\n  }\n  /** Enter the frameloop */\n\n\n  _start() {\n    if (this.idle) {\n      this._phase = ACTIVE; // Animations without \"onRest\" cannot enter the frameloop.\n\n      const anim = this.animation;\n\n      if (anim.onRest) {\n        anim.changed = false; // The \"skipAnimation\" global avoids the frameloop.\n\n        if (skipAnimation) {\n          this.finish(anim.to);\n        } else {\n          frameLoop.start(this);\n        }\n      }\n\n      super._start();\n    }\n  }\n  /** Exit the frameloop and notify `onRest` listeners */\n\n\n  _stop(finished = false) {\n    if (!this.idle) {\n      this._phase = IDLE; // Always let change observers know when a spring becomes idle.\n\n      this._onChange(this.get(), true);\n\n      const anim = this.animation;\n      const onRestQueue = anim.onRest; // Animations without \"onRest\" never enter the frameloop.\n\n      if (onRestQueue) {\n        each(anim.values, node => {\n          node.done = true;\n        }); // Preserve the \"onRest\" prop between animations.\n\n        anim.onRest = [onRestQueue[0]]; // Never call the \"onRest\" prop for immediate or no-op animations.\n\n        if (anim.immediate || !anim.changed) {\n          onRestQueue[0] = noop;\n        }\n\n        batchedUpdates(() => {\n          const result = {\n            value: this.get(),\n            spring: this,\n            finished\n          };\n          each(onRestQueue, onRest => {\n            onRest(result);\n          });\n        });\n      }\n    }\n  }\n\n} // TODO: makes this tree-shakeable\n\n\nfunction checkDisposed(spring, name) {\n  if (spring.is(DISPOSED)) {\n    throw Error(`Cannot call \"${name}\" of disposed \"${spring.constructor.name}\" object`);\n  }\n} // Merge configs when the existence of \"decay\" or \"duration\" has not changed.\n\n\nfunction canMergeConfigs(src, dest) {\n  return !!dest && is.und(src.decay) == is.und(dest.decay) && is.und(src.duration) == is.und(dest.duration) && is.und(src.frequency) == is.und(dest.frequency);\n} // Compute the goal value, converting \"red\" to \"rgba(255, 0, 0, 1)\" in the process\n\n\nfunction computeGoal(value) {\n  const config = getFluidConfig(value);\n  return config ? computeGoal(config.get()) : is.arr(value) ? value.map(computeGoal) : isAnimatedString(value) ? createStringInterpolator({\n    range: [0, 1],\n    output: [value, value]\n  })(1) : value;\n}\n\nlet nextId$1 = 1;\nlet lastAsyncId = 0;\n\nclass Controller {\n  constructor(props) {\n    this.id = nextId$1++;\n    /** The values that changed in the last animation frame */\n\n    this.frame = {};\n    /** Fallback values for undefined props */\n\n    this.defaultProps = {};\n    /** The queue of pending props */\n\n    this.queue = [];\n    /** The current controller-only props (eg: `onFrame` and async state) */\n\n    this._state = {};\n    /** The spring values that manage their animations */\n\n    this._springs = {};\n    this._onFrame = this._onFrame.bind(this);\n\n    if (props) {\n      props.default = true;\n      this.start(props);\n    }\n  }\n  /** Equals true when no springs are animating */\n\n\n  get idle() {\n    return !this._state.promise && Object.values(this._springs).every(s => s.idle);\n  }\n  /** Get all existing `SpringValue` objects. This clones the internal store. */\n\n\n  get springs() {\n    return _extends({}, this._springs);\n  }\n\n  get(key) {\n    return this._springs[key];\n  }\n  /** Push an update onto the queue of each value. */\n\n\n  update(props) {\n    if (props) this.queue.push(this._update(props));\n    return this;\n  }\n  /**\r\n   * Start the queued animations for every spring, and resolve the returned\r\n   * promise once all queued animations have finished or been cancelled.\r\n   *\r\n   * When you pass a queue (instead of nothing), that queue is used instead of\r\n   * the queued animations added with the `update` method, which are left alone.\r\n   */\n\n\n  async start(queue) {\n    if (queue) {\n      queue = toArray(queue).map(props => this._update(props));\n    } else {\n      queue = this.queue;\n      this.queue = [];\n    }\n\n    const promises = [];\n    each(queue, props => {\n      const {\n        to,\n        onFrame,\n        keys\n      } = props;\n      const asyncTo = (is.arr(to) || is.fun(to)) && to;\n\n      if (asyncTo) {\n        props.to = undefined;\n      }\n\n      const state = this._state;\n      promises.push( // Send updates to every affected key.\n      ...keys.map(key => this._springs[key].start(props)), // Schedule controller-only props.\n      scheduleProps(++lastAsyncId, {\n        props,\n        state,\n        action: (props, resolve) => {\n          if (!props.cancel) {\n            // Never reuse \"onFrame\" from a previous update.\n            state.onFrame = onFrame || this.defaultProps.onFrame;\n\n            if (onFrame && props.default) {\n              this.defaultProps.onFrame = onFrame;\n            }\n          } // Start, replace, or cancel the async animation.\n\n\n          if (asyncTo) {\n            resolve(runAsync(asyncTo, props, state, this._get.bind(this), () => false, // TODO: add pausing to Controller\n            this.start.bind(this), this.stop.bind(this)));\n          } else {\n            resolve({\n              value: 0,\n              finished: !props.cancel\n            });\n          }\n        }\n      }));\n    });\n    const results = await Promise.all(promises);\n    return {\n      value: this._get(),\n      finished: results.every(result => result.finished)\n    };\n  }\n  /** Stop one animation, some animations, or all animations */\n\n\n  stop(keys) {\n    if (is.und(keys)) {\n      each(this._springs, spring => spring.stop());\n    } else {\n      each(toArray(keys), key => this._springs[key].stop());\n    }\n\n    return this;\n  }\n  /** Restart every animation. */\n\n\n  reset() {\n    each(this._springs, spring => spring.reset()); // TODO: restart async \"to\" prop\n\n    return this;\n  }\n  /** Destroy every spring in this controller */\n\n\n  dispose() {\n    this._state.asyncTo = undefined;\n    each(this._springs, spring => spring.dispose());\n    this._springs = {};\n  }\n  /** Get the current value of every spring */\n\n\n  _get() {\n    const values = {};\n    each(this._springs, (spring, key) => {\n      values[key] = spring.get();\n    });\n    return values;\n  }\n  /** Create a spring for every given key, and ensure they have `Animated` nodes. */\n\n\n  _setSprings(keys, from, to) {\n    each(keys, key => {\n      if (!this._springs[key]) {\n        const spring = this._springs[key] = new SpringValue();\n        spring.key = key;\n        spring.addChild(this);\n        spring.setNodeWithProps({\n          from,\n          to\n        });\n      }\n    });\n  }\n  /** Prepare an update with the given props. */\n\n\n  _update(propsArg) {\n    const props = interpolateTo(propsArg);\n    const keys = props.keys = extractKeys(props, this._springs);\n    let {\n      from,\n      to\n    } = props; // Avoid sending async \"to\" prop to springs.\n\n    if (is.arr(to) || is.fun(to)) {\n      to = undefined;\n    } // Create our springs and give them values.\n\n\n    if (from || to) {\n      this._setSprings(keys, from, to);\n    }\n\n    return props;\n  }\n  /** @internal */\n\n\n  onParentChange(event) {\n    if (this._state.onFrame && event.type == 'change') {\n      this.frame[event.parent.key] = event.value;\n      frameLoop.onFrame(this._onFrame);\n    }\n  }\n  /** @internal Called at the end of every animation frame */\n\n\n  _onFrame() {\n    if (Object.keys(this.frame).length) {\n      this._state.onFrame(this.frame);\n\n      this.frame = {};\n    }\n  }\n\n}\n/** Determine which keys should receive an update */\n\n\nfunction extractKeys(props, springs) {\n  const keys = new Set();\n  /** Collect keys with a defined value */\n\n  const getDefinedKeys = obj => each(obj, (value, key) => {\n    if (!is.und(value)) {\n      keys.add(key);\n    }\n  });\n\n  const {\n    from,\n    to\n  } = props;\n  if (is.obj(to)) getDefinedKeys(to);\n  if (from) getDefinedKeys(from); // When neither \"from\" or \"to\" have a key with a defined value,\n  // return the keys for every existing spring.\n\n  return keys.size ? Array.from(keys) : Object.keys(springs);\n}\n/** @internal */\n\n\nfunction useSprings(length, props, deps) {\n  const propsFn = is.fun(props) && props;\n\n  if (propsFn && arguments.length < 3) {\n    deps = []; // Skip updates after first render.\n  } // The \"ref\" prop is taken from the props of the first spring only.\n  // The ref is assumed to *never* change after the first render.\n\n\n  let ref;\n  const ctrls = useMemo(() => [], []);\n  const updates = [];\n  const prevLength = usePrev(length) || 0;\n  useMemo(() => {\n    if (prevLength > length) {\n      for (let i = length; i < prevLength; i++) {\n        ctrls[i].dispose();\n      }\n    }\n\n    ctrls.length = length;\n\n    for (let i = 0; i < length; i++) {\n      const ctrl = ctrls[i] || (ctrls[i] = new Controller());\n      const update = propsFn ? propsFn(i, ctrl) : props[i];\n\n      if (update) {\n        update.default = true;\n\n        if (i == 0 && update.ref) {\n          ref = update.ref;\n        }\n\n        if (i < prevLength) {\n          updates[i] = update;\n        } else {\n          // Update new controllers immediately, so their\n          // spring values exist during first render.\n          ctrl.update(update);\n        }\n      }\n    }\n  }, deps);\n  const api = useMemo$1(() => ({\n    get controllers() {\n      return ctrls;\n    },\n\n    update: props => {\n      each(ctrls, (ctrl, i) => {\n        ctrl.update(getProps(props, i, ctrl));\n        if (!ref) ctrl.start();\n      });\n      return api;\n    },\n\n    async start() {\n      const results = await Promise.all(ctrls.map(ctrl => ctrl.start()));\n      return {\n        value: results.map(result => result.value),\n        finished: results.every(result => result.finished)\n      };\n    },\n\n    stop: keys => each(ctrls, ctrl => ctrl.stop(keys))\n  }), []);\n  useImperativeHandle(ref, () => api);\n  useIsomorphicLayoutEffect(() => {\n    each(updates, (update, i) => ctrls[i].update(update));\n\n    if (!ref) {\n      each(ctrls, ctrl => ctrl.start());\n    }\n  }, deps);\n  useOnce(() => () => {\n    each(ctrls, ctrl => ctrl.dispose());\n  });\n  const values = ctrls.map(ctrl => ctrl.springs);\n  return propsFn || arguments.length == 3 ? [values, api.update, api.stop] : values;\n}\n/** @internal */\n\n\nfunction useSpring(props, deps) {\n  const isFn = is.fun(props);\n  const [[values], update, stop] = useSprings(1, isFn ? props : [props], deps);\n  return isFn || arguments.length == 3 ? [values, update, stop] : values;\n}\n\nfunction useTrail(length, propsArg, deps) {\n  const propsFn = is.fun(propsArg) && propsArg;\n\n  if (propsFn && arguments.length < 3) {\n    deps = []; // Skip updates after first render.\n  }\n\n  const ctrls = [];\n  const result = useSprings(length, (i, ctrl) => {\n    ctrls[i] = ctrl;\n    return getProps(propsArg, i, ctrl);\n  }, deps);\n  useIsomorphicLayoutEffect(() => {\n    const reverse = is.obj(propsArg) && propsArg.reverse;\n\n    for (let i = 0; i < ctrls.length; i++) {\n      const parent = ctrls[i + (reverse ? 1 : -1)];\n      if (parent) ctrls[i].update({\n        to: parent.springs\n      }).start();\n    }\n  }, deps);\n  const update = result[1];\n\n  result[1] = propsArg => {\n    const reverse = is.obj(propsArg) && propsArg.reverse;\n    return update((i, ctrl) => {\n      const props = getProps(propsArg, i, ctrl);\n      const parent = ctrls[i + (reverse ? 1 : -1)];\n      if (parent) props.to = parent.springs;\n      return props;\n    });\n  };\n\n  return propsFn ? result : result[0];\n}\n/** This transition is being mounted */\n\n\nconst MOUNT = 0;\n/** This transition is entering or has entered */\n\nconst ENTER = 1;\n/** This transition had its animations updated */\n\nconst UPDATE = 2;\n/** This transition will expire after animating */\n\nconst LEAVE = 3;\n\nfunction getKeys(items, {\n  key,\n  keys = key\n}) {\n  return is.und(keys) ? items : is.fun(keys) ? items.map(keys) : toArray(keys);\n}\n\nfunction useTransition(data, props, deps) {\n  const {\n    ref,\n    reset,\n    sort,\n    trail = 0,\n    expires = Infinity\n  } = props; // Every item has its own transition.\n\n  const items = toArray(data);\n  const transitions = []; // Keys help with reusing transitions between renders.\n  // The `key` prop can be undefined (which means the items themselves are used\n  // as keys), or a function (which maps each item to its key), or an array of\n  // keys (which are assigned to each item by index).\n\n  const keys = getKeys(items, props); // The \"onRest\" callbacks need a ref to the latest transitions.\n\n  const usedTransitions = useRef(null);\n  const prevTransitions = usedTransitions.current;\n  useIsomorphicLayoutEffect(() => {\n    usedTransitions.current = transitions;\n  }); // Destroy all transitions on dismount.\n\n  useOnce(() => () => each(usedTransitions.current, t => {\n    if (t.expiresBy != null) {\n      clearTimeout(t.expirationId);\n    }\n\n    t.ctrl.dispose();\n  })); // Map old indices to new indices.\n\n  const reused = [];\n  if (prevTransitions && !reset) each(prevTransitions, (t, i) => {\n    // Expired transitions are not rendered.\n    if (t.expiresBy != null) {\n      clearTimeout(t.expirationId);\n    } else {\n      i = reused[i] = keys.indexOf(t.key);\n      if (~i) transitions[i] = t;\n    }\n  }); // Mount new items with fresh transitions.\n\n  each(items, (item, i) => {\n    transitions[i] || (transitions[i] = {\n      key: keys[i],\n      item,\n      phase: MOUNT,\n      ctrl: new Controller()\n    });\n  }); // Update the item of any transition whose key still exists,\n  // and ensure leaving transitions are rendered until they finish.\n\n  if (reused.length) {\n    let i = -1;\n    each(reused, (keyIndex, prevIndex) => {\n      const t = prevTransitions[prevIndex];\n\n      if (~keyIndex) {\n        i = transitions.indexOf(t);\n        transitions[i] = _extends({}, t, {\n          item: items[keyIndex]\n        });\n      } else if (props.leave) {\n        transitions.splice(++i, 0, t);\n      }\n    });\n  }\n\n  if (is.fun(sort)) {\n    transitions.sort((a, b) => sort(a.item, b.item));\n  } // Track cumulative delay for the \"trail\" prop.\n\n\n  let delay = -trail; // Expired transitions use this to dismount.\n\n  const forceUpdate = useForceUpdate();\n  const defaultProps = {};\n  each(DEFAULT_PROPS, prop => {\n    if (/function|object/.test(typeof props[prop])) {\n      defaultProps[prop] = props[prop];\n    }\n  }); // Generate changes to apply in useEffect.\n\n  const changes = new Map();\n  each(transitions, (t, i) => {\n    let to;\n    let from;\n    let phase;\n\n    if (t.phase == MOUNT) {\n      to = props.enter;\n      phase = ENTER; // The \"initial\" prop is only used on first render. It always overrides\n      // the \"from\" prop when defined, and it makes \"enter\" instant when null.\n\n      from = props.initial;\n\n      if (is.und(from) || prevTransitions && !reset) {\n        from = props.from;\n      }\n    } else {\n      const isLeave = keys.indexOf(t.key) < 0;\n\n      if (t.phase < LEAVE) {\n        if (isLeave) {\n          to = props.leave;\n          phase = LEAVE;\n        } else if (to = props.update) {\n          phase = UPDATE;\n        } else return;\n      } else if (!isLeave) {\n        to = props.enter;\n        phase = ENTER;\n      } else return;\n    } // The payload is used to update the spring props once the current render is committed.\n\n\n    const payload = _extends({}, defaultProps, {\n      // When \"to\" is a function, it can return (1) an array of \"useSpring\" props,\n      // (2) an async function, or (3) an object with any \"useSpring\" props.\n      to: to = callProp(to, t.item, i),\n      from: callProp(from, t.item, i),\n      delay: delay += trail,\n      config: callProp(props.config || defaultProps.config, t.item, i)\n    }, is.obj(to) && interpolateTo(to));\n\n    const {\n      onRest\n    } = payload;\n\n    payload.onRest = result => {\n      if (is.fun(onRest)) {\n        onRest(result);\n      }\n\n      if (t.phase == LEAVE && t.ctrl.idle) {\n        t.expiresBy = now() + expires;\n\n        if (expires <= 0) {\n          forceUpdate();\n        } else {\n          // Postpone dismounts while other controllers are active.\n          const transitions = usedTransitions.current;\n\n          if (transitions.every(t => t.ctrl.idle)) {\n            forceUpdate();\n          } // When `expires` is infinite, postpone dismount until next render.\n          else if (expires < Infinity) {\n            t.expirationId = setTimeout(forceUpdate, expires);\n          }\n        }\n      }\n    };\n\n    const change = {\n      phase\n    };\n    changes.set(t, change); // To ensure all Animated nodes exist during render,\n    // the payload must be applied immediately for new items.\n\n    if (t.phase > MOUNT) {\n      change.payload = payload;\n    } else {\n      t.ctrl.update(payload);\n    }\n  });\n  const api = useMemo$1(() => ({\n    get controllers() {\n      return usedTransitions.current.map(t => t.ctrl);\n    },\n\n    update(props) {\n      each(usedTransitions.current, (t, i) => t.ctrl.update(is.fun(props) ? props(i, t.ctrl) : is.arr(props) ? props[i] : props));\n      return api;\n    },\n\n    async start() {\n      const transitions = usedTransitions.current;\n      const results = await Promise.all(transitions.map(t => t.ctrl.start()));\n      return {\n        value: results.map(result => result.value),\n        finished: results.every(result => result.finished)\n      };\n    },\n\n    stop: keys => each(usedTransitions.current, t => t.ctrl.stop(keys))\n  }), []);\n  useImperativeHandle(ref, () => api);\n  useIsomorphicLayoutEffect(() => {\n    each(changes, ({\n      phase,\n      payload\n    }, t) => {\n      t.phase = phase;\n      if (payload) t.ctrl.update(payload);\n      if (!ref) t.ctrl.start();\n    });\n  }, reset ? void 0 : deps);\n  return render => transitions.map(t => {\n    const elem = render(t.ctrl.springs, t.item, t);\n    return elem && elem.type ? React.createElement(elem.type, Object.assign({}, elem.props, {\n      key: is.str(t.key) || is.num(t.key) ? t.key : t.ctrl.id,\n      ref: elem.ref\n    })) : elem;\n  });\n}\n\nfunction Spring(_ref) {\n  let props = _objectWithoutPropertiesLoose(_ref, [\"children\"]);\n\n  return children(useSpring(props));\n}\n\nfunction Trail(_ref2) {\n  let {\n    items\n  } = _ref2,\n      props = _objectWithoutPropertiesLoose(_ref2, [\"items\", \"children\"]);\n\n  const trails = useTrail(items.length, props);\n  return items.map((item, index) => {\n    const result = children(item, index);\n    return is.fun(result) ? result(trails[index]) : result;\n  });\n}\n\nfunction Transition(_ref3) {\n  let props = _objectWithoutPropertiesLoose(_ref3, [\"items\", \"children\"]);\n\n  return useTransition(items, props)(children);\n}\n/**\r\n * An `Interpolation` is a memoized value that's computed whenever one of its\r\n * `FluidValue` dependencies has its value changed.\r\n *\r\n * Other `FrameValue` objects can depend on this. For example, passing an\r\n * `Interpolation` as the `to` prop of a `useSpring` call will trigger an\r\n * animation toward the memoized value.\r\n */\n\n\nclass Interpolation extends FrameValue {\n  constructor(\n  /** The source of input values */\n  source, args) {\n    super();\n    this.source = source;\n    /** Equals false when in the frameloop */\n\n    this.idle = true;\n    this.calc = createInterpolator(...args);\n\n    const value = this._get();\n\n    const nodeType = is.arr(value) ? AnimatedArray : AnimatedValue; // Assume the computed value never changes type.\n\n    setAnimated(this, nodeType.create(value));\n  }\n\n  advance(_dt) {\n    const value = this._get();\n\n    const oldValue = this.get();\n\n    if (!isEqual(value, oldValue)) {\n      getAnimated(this).setValue(value);\n\n      this._onChange(value, this.idle);\n    }\n  }\n\n  _get() {\n    const inputs = is.arr(this.source) ? this.source.map(node => node.get()) : toArray(this.source.get());\n    return this.calc(...inputs);\n  }\n\n  _start() {\n    if (this.idle) {\n      this.idle = false;\n\n      super._start();\n\n      if (skipAnimation) {\n        this.idle = true;\n        this.advance();\n      } else {\n        frameLoop.start(this);\n      }\n    }\n  }\n\n  _reset() {\n    each(getPayload(this), node => node.reset());\n\n    super._reset();\n  }\n\n  _attach() {\n    // Start observing our \"source\" once we have an observer.\n    let idle = true;\n    let priority = 1;\n    each(toArray(this.source), source => {\n      if (isFrameValue(source)) {\n        if (!source.idle) idle = false;\n        priority = Math.max(priority, source.priority + 1);\n      }\n\n      source.addChild(this);\n    });\n    this.priority = priority;\n\n    if (!idle) {\n      this._reset();\n\n      this._start();\n    }\n  }\n\n  _detach() {\n    // Stop observing our \"source\" once we have no observers.\n    each(toArray(this.source), source => {\n      source.removeChild(this);\n    });\n    this.idle = true;\n  }\n  /** @internal */\n\n\n  onParentChange(event) {\n    if (event.type == 'change') {\n      if (this.idle) {\n        this.advance();\n      } // Leave the frameloop when all parent values are done animating.\n      else if (event.idle) {\n        this.idle = toArray(this.source).every(source => source.idle !== false);\n\n        if (this.idle) {\n          this.advance();\n          each(getPayload(this), node => {\n            node.done = true;\n          });\n        }\n      }\n    } else if (event.type == 'priority') {\n      // Set our priority to 1 + the highest parent.\n      this.priority = toArray(this.source).reduce((max, source) => Math.max(max, (source.priority || 0) + 1), 0);\n    }\n\n    super.onParentChange(event);\n  }\n\n}\n/** Map the value of one or more dependencies */\n\n\nconst to = (source, ...args) => new Interpolation(source, args);\n/** @deprecated Use the `to` export instead */\n\n\nconst interpolate = (source, ...args) => (deprecateInterpolate(), new Interpolation(source, args));\n\nGlobals.assign({\n  applyAnimatedValues: () => false,\n  createStringInterpolator: createStringInterpolator$1,\n  to: (source, args) => new Interpolation(source, args)\n});\n/** Advance all animations forward one frame */\n\nconst update = () => Globals.frameLoop.update();\n\nexport { Controller, FrameValue, Interpolation, Spring, SpringValue, Trail, Transition, config, interpolate, isFrameValue, to, update, useChain, useSpring, useSprings, useTrail, useTransition };","map":{"version":3,"sources":["src/useChain.js","src/helpers.ts","src/runAsync.ts","src/constants.ts","src/Animation.ts","src/FrameValue.ts","src/SpringValue.ts","src/Controller.ts","src/useSprings.ts","src/useSpring.ts","src/useTrail.ts","src/useTransition.tsx","src/legacy.js","src/Interpolation.ts","src/interpolate.ts","src/globals.ts"],"names":["timeFrame","useIsomorphicLayoutEffect","prevDelay","each","ref","controllers","delay","timeSteps","isNaN","ctrl","props","p","Promise","start","updates","q","useMemo","useMemoOne","deps","callProp","value","args","is","matchProp","key","toArray","getProps","DEFAULT_PROPS","RESERVED_PROPS","children","config","from","to","reset","cancel","reverse","immediate","default","lazy","items","trail","sort","expires","initial","enter","leave","update","onAnimate","onStart","onRest","onChange","onFrame","forward","interpolateTo","getForwardProps","out","state","getValue","cancelled","asyncId","cancelToken","Symbol","isCancelled","defaultProps","prop","animate","arg1","parentTo","getPaused","resolve","result","finished","err","scheduleProps","action","setTimeout","run","reject","tension","friction","gentle","wobbly","stiff","slow","molasses","none","emptyArray","defaultConfig","constants","linear","t","Animation","AnimationConfig","merge","damping","Object","Math","isFrameValue","nextId","FrameValue","FluidValue","priority","velocity","node","getAnimated","get","G","interpolate","deprecateInterpolate","addChild","removeChild","onParentChange","event","_attach","_detach","_reset","type","parent","goal","_start","_onChange","idle","_onPriorityChange","_emit","Array","child","DISPOSED","CREATED","IDLE","PAUSED","ACTIVE","SpringValue","constructor","arg2","arguments","advance","changed","anim","payload","getPayload","toValues","toConfig","getFluidConfig","canFinish","elapsed","v0","position","decay","e","precision","restVelocity","bounceFactor","canBounce","isGrowing","isBouncing","step","numSteps","dt","n","isMoving","springForce","dampingForce","acceleration","Number","console","set","pause","checkDisposed","finish","queue","spring","stop","dispose","_ensureAnimated","nodeType","setAnimated","computeGoal","setNodeWithProps","range","_getNodeType","parentNode","parentType","isAnimatedString","_getRange","_animate","timestamp","runAsync","_update","timestamps","diff","prevFrom","fromConfig","isEqual","started","lastVelocity","canMergeConfigs","Error","onRestQueue","i","_to","_set","_stop","name","src","dest","output","lastAsyncId","Controller","s","springs","promises","keys","asyncTo","results","_get","values","_setSprings","extractKeys","_onFrame","getDefinedKeys","obj","useSprings","length","propsFn","ctrls","prevLength","usePrev","api","useImperativeHandle","useOnce","useSpring","isFn","useTrail","propsArg","MOUNT","ENTER","UPDATE","LEAVE","useTransition","data","Infinity","transitions","getKeys","usedTransitions","useRef","prevTransitions","clearTimeout","reused","phase","item","a","b","forceUpdate","useForceUpdate","changes","isLeave","now","change","render","elem","id","trails","Interpolation","source","createInterpolator","oldValue","inputs","Globals","applyAnimatedValues"],"mappings":"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","sourcesContent":["import { useIsomorphicLayoutEffect, each, is, toArray, FluidValue, getFluidConfig, isAnimatedString, isEqual, noop, usePrev, useOnce, useForceUpdate, createInterpolator, Globals } from '@react-spring/shared';\nexport { FrameLoop, Globals, createInterpolator } from '@react-spring/shared';\nimport React, { useMemo as useMemo$1, useImperativeHandle, useRef } from 'react';\nimport _extends from '@babel/runtime/helpers/esm/extends';\nimport { to as to$1, frameLoop, createStringInterpolator, now, skipAnimation, batchedUpdates } from '@react-spring/shared/globals';\nimport { useMemoOne } from 'use-memo-one';\nimport { getAnimated, AnimatedValue, getPayload, setAnimated, AnimatedString, AnimatedArray } from '@react-spring/animated';\nimport { deprecateInterpolate } from '@react-spring/shared/deprecations';\nimport _objectWithoutPropertiesLoose from '@babel/runtime/helpers/esm/objectWithoutPropertiesLoose';\nimport { createStringInterpolator as createStringInterpolator$1 } from '@react-spring/shared/stringInterpolation';\n\n/** API\n *  useChain(references, timeSteps, timeFrame)\n */\n\nfunction useChain(refs, timeSteps, timeFrame = 1000) {\n  useIsomorphicLayoutEffect(() => {\n    if (timeSteps) {\n      let prevDelay = 0;\n      each(refs, (ref, i) => {\n        if (!ref.current) return;\n        const {\n          controllers\n        } = ref.current;\n\n        if (controllers.length) {\n          let delay = timeFrame * timeSteps[i]; // Use the previous delay if none exists.\n\n          if (isNaN(delay)) delay = prevDelay;else prevDelay = delay;\n          each(controllers, ctrl => {\n            each(ctrl.queue, props => {\n              props.delay = delay + (props.delay || 0);\n            });\n            ctrl.start();\n          });\n        }\n      });\n    } else {\n      let p = Promise.resolve();\n      each(refs, ref => {\n        const {\n          controllers,\n          start\n        } = ref.current || {};\n\n        if (controllers && controllers.length) {\n          // Take the queue of each controller\n          const updates = controllers.map(ctrl => {\n            const q = ctrl.queue;\n            ctrl.queue = [];\n            return q;\n          }); // Apply the queue when the previous ref stops animating\n\n          p = p.then(() => {\n            each(controllers, (ctrl, i) => ctrl.queue.push(...updates[i]));\n            return start();\n          });\n        }\n      });\n    }\n  });\n}\n\nconst useMemo = (create, deps) => useMemoOne(create, deps || [{}]);\nfunction callProp(value, ...args) {\n  return is.fun(value) ? value(...args) : value;\n}\n/** Try to coerce the given value into a boolean using the given key */\n\nconst matchProp = (value, key) => value === true || !!(key && value && (is.fun(value) ? value(key) : toArray(value).includes(key)));\nconst getProps = (props, i, arg) => is.fun(props) ? props(i, arg) : is.arr(props) ? props[i] : _extends({}, props);\n/** These props can have default values */\n\nconst DEFAULT_PROPS = ['config', 'immediate', 'onAnimate', 'onStart', 'onChange', 'onRest'];\nconst RESERVED_PROPS = {\n  children: 1,\n  config: 1,\n  from: 1,\n  to: 1,\n  ref: 1,\n  reset: 1,\n  cancel: 1,\n  reverse: 1,\n  immediate: 1,\n  default: 1,\n  delay: 1,\n  lazy: 1,\n  items: 1,\n  trail: 1,\n  sort: 1,\n  expires: 1,\n  initial: 1,\n  enter: 1,\n  leave: 1,\n  update: 1,\n  onAnimate: 1,\n  onStart: 1,\n  onRest: 1,\n  onChange: 1,\n  onFrame: 1\n};\n/**\r\n * Extract any properties whose keys are *not* reserved for customizing your\r\n * animations. All hooks use this function, which means `useTransition` props\r\n * are reserved for `useSpring` calls, etc.\r\n */\n\nfunction getForwardProps(props) {\n  const forward = {};\n  each(props, (value, prop) => {\n    if (!RESERVED_PROPS[prop]) {\n      forward[prop] = value;\n    }\n  });\n  return forward;\n}\n\nfunction interpolateTo(props) {\n  const to = getForwardProps(props);\n  const out = {\n    to\n  };\n  each(props, (val, key) => key in to || (out[key] = val));\n  return out;\n}\n\n/**\r\n * Start an async chain or an async script.\r\n *\r\n * You should always wrap `runAsync` calls with `scheduleProps` so that\r\n * you have access to `RunAsyncProps` instead of the usual `SpringProps`.\r\n *\r\n * The `T` parameter can be a set of animated values (as an object type)\r\n * or a primitive type for a single animated value.\r\n */\n\nasync function runAsync(to, props, state, getValue, getPaused, update, stop) {\n  if (props.cancel) {\n    state.asyncTo = undefined;\n    return {\n      value: getValue(),\n      cancelled: true\n    };\n  } // Wait for the previous async animation to be cancelled.\n  else if (props.reset) {\n      await state.promise;\n    } // Async animations are only replaced when \"props.to\" changes\n    // or when \"props.reset\" equals true.\n    else if (to === state.asyncTo) {\n        return state.promise;\n      }\n\n  state.asyncTo = to;\n  return state.promise = (async () => {\n    const {\n      asyncId\n    } = props;\n    const cancelToken = Symbol.for('cancel');\n\n    const isCancelled = () => to !== state.asyncTo || asyncId <= (state.cancelId || 0);\n\n    const defaultProps = {};\n    each(DEFAULT_PROPS, prop => {\n      if (prop == 'onRest') return;\n\n      if (/function|object/.test(typeof props[prop])) {\n        defaultProps[prop] = props[prop];\n      }\n    });\n\n    const animate = (arg1, arg2) => {\n      if (isCancelled()) {\n        throw cancelToken;\n      }\n\n      const props = is.obj(arg1) ? _extends({}, arg1) : _extends({}, arg2, {\n        to: arg1\n      });\n      each(defaultProps, (value, prop) => {\n        if (is.und(props[prop])) {\n          props[prop] = value;\n        }\n      });\n      const parentTo = state.asyncTo;\n      return update(props).then(async result => {\n        if (state.asyncTo == null) {\n          state.asyncTo = parentTo;\n        }\n\n        if (isCancelled()) {\n          throw cancelToken;\n        }\n\n        if (getPaused()) {\n          await new Promise(resolve => {\n            state.unpause = resolve;\n          });\n          state.unpause = undefined;\n        }\n\n        return result;\n      });\n    };\n\n    let result;\n\n    try {\n      // Async sequence\n      if (is.arr(to)) {\n        for (const props of to) {\n          await animate(props);\n        }\n      } // Async script\n      else if (is.fun(to)) {\n          await to(animate, stop);\n        }\n\n      result = {\n        value: getValue(),\n        finished: true\n      };\n    } catch (err) {\n      if (err !== cancelToken) {\n        throw err;\n      }\n\n      result = {\n        value: getValue(),\n        cancelled: true\n      };\n    } finally {\n      state.promise = undefined;\n\n      if (to == state.asyncTo) {\n        state.asyncTo = undefined;\n      }\n    }\n\n    if (props.onRest) {\n      props.onRest(result);\n    }\n\n    return result;\n  })();\n} //\n// scheduleProps(props, state, action)\n//\n\n/**\r\n * Pass props to your action when any delay is finished and the\r\n * props weren't cancelled before then.\r\n */\n\nfunction scheduleProps(asyncId, {\n  key,\n  props,\n  state,\n  action\n}) {\n  return new Promise((resolve, reject) => {\n    let {\n      delay,\n      cancel,\n      reset\n    } = props;\n\n    if (is.num(delay) && delay > 0) {\n      setTimeout(run, delay);\n    } else run();\n\n    function run() {\n      // Might be cancelled during delay.\n      if (asyncId <= (state.cancelId || 0)) {\n        cancel = true;\n      } else {\n        cancel = matchProp(cancel, key);\n\n        if (cancel) {\n          state.cancelId = asyncId;\n        }\n      }\n\n      reset = !cancel && matchProp(reset, key);\n\n      try {\n        action(_extends({}, props, {\n          asyncId,\n          cancel,\n          reset\n        }), resolve);\n      } catch (err) {\n        reject(err);\n      }\n    }\n  });\n}\n\n// The `mass` prop defaults to 1\nconst config = {\n  default: {\n    tension: 170,\n    friction: 26\n  },\n  gentle: {\n    tension: 120,\n    friction: 14\n  },\n  wobbly: {\n    tension: 180,\n    friction: 12\n  },\n  stiff: {\n    tension: 210,\n    friction: 20\n  },\n  slow: {\n    tension: 280,\n    friction: 60\n  },\n  molasses: {\n    tension: 280,\n    friction: 120\n  }\n};\n\nconst none = undefined;\nconst emptyArray = [];\nconst defaultConfig = config.default;\n/** Accelerate until halfway, then decelerate */\n\nconst linear = t => t;\n/** An animation being executed by the frameloop */\n\n\nclass Animation {\n  constructor() {\n    this.changed = false;\n    this.values = emptyArray;\n    this.to = none;\n    this.toValues = null;\n    this.from = none;\n    this.fromValues = emptyArray;\n    this.config = new AnimationConfig();\n    this.reverse = false;\n    this.immediate = false;\n    this.onStart = none;\n    this.onChange = none;\n    this.onRest = none;\n  }\n\n}\nclass AnimationConfig {\n  constructor() {\n    /**\r\n     * With higher tension, the spring will resist bouncing and try harder to stop at its end value.\r\n     *\r\n     * When tension is zero, no animation occurs.\r\n     */\n    this.tension = defaultConfig.tension;\n    /**\r\n     * The damping ratio coefficient, or just the damping ratio when `speed` is defined.\r\n     *\r\n     * When `speed` is defined, this value should be between 0 and 1.\r\n     *\r\n     * Higher friction means the spring will slow down faster.\r\n     */\n\n    this.friction = defaultConfig.friction;\n    /**\r\n     * The natural frequency (in seconds), which dictates the number of bounces\r\n     * per second when no damping exists.\r\n     *\r\n     * When defined, `tension` is derived from this, and `friction` is derived\r\n     * from `tension` and `damping`.\r\n     */\n\n    this.frequency = none;\n    /**\r\n     * The damping ratio, which dictates how the spring slows down.\r\n     *\r\n     * Set to `0` to never slow down. Set to `1` to slow down without bouncing.\r\n     * Between `0` and `1` is for you to explore.\r\n     *\r\n     * Only works when `frequency` is defined.\r\n     *\r\n     * Defaults to 1\r\n     */\n\n    this.damping = 1;\n    /**\r\n     * Higher mass means more friction is required to slow down.\r\n     *\r\n     * Defaults to 1, which works fine most of the time.\r\n     */\n\n    this.mass = 1;\n    /**\r\n     * The initial velocity of one or more values.\r\n     */\n\n    this.velocity = 0;\n    /**\r\n     * The smallest velocity before the animation is considered \"not moving\".\r\n     *\r\n     * When undefined, `precision` is used instead.\r\n     */\n\n    this.restVelocity = none;\n    /**\r\n     * The smallest distance from a value before that distance is essentially zero.\r\n     *\r\n     * This helps in deciding when a spring is \"at rest\". The spring must be within\r\n     * this distance from its final value, and its velocity must be lower than this\r\n     * value too (unless `restVelocity` is defined).\r\n     */\n\n    this.precision = none;\n    /**\r\n     * For `duration` animations only. Note: The `duration` is not affected\r\n     * by this property.\r\n     *\r\n     * Defaults to `0`, which means \"start from the beginning\".\r\n     *\r\n     * Setting to `1+` makes an immediate animation.\r\n     *\r\n     * Setting to `0.5` means \"start from the middle of the easing function\".\r\n     *\r\n     * Any number `>= 0` and `<= 1` makes sense here.\r\n     */\n\n    this.progress = none;\n    /**\r\n     * Animation length in number of milliseconds.\r\n     */\n\n    this.duration = none;\n    /**\r\n     * The animation curve. Only used when `duration` is defined.\r\n     *\r\n     * Defaults to quadratic ease-in-out.\r\n     */\n\n    this.easing = linear;\n    /**\r\n     * Avoid overshooting by ending abruptly at the goal value.\r\n     */\n\n    this.clamp = false;\n    /**\r\n     * When above zero, the spring will bounce instead of overshooting when\r\n     * exceeding its goal value. Its velocity is multiplied by `-1 + bounce`\r\n     * whenever its current value equals or exceeds its goal. For example,\r\n     * setting `bounce` to `0.5` chops the velocity in half on each bounce,\r\n     * in addition to any friction.\r\n     */\n\n    this.bounce = none;\n    /**\r\n     * \"Decay animations\" decelerate without an explicit goal value.\r\n     * Useful for scrolling animations.\r\n     *\r\n     * Use `true` for the default exponential decay factor (`0.998`).\r\n     *\r\n     * When a `number` between `0` and `1` is given, a lower number makes the\r\n     * animation slow down faster. And setting to `1` would make an unending\r\n     * animation.\r\n     */\n\n    this.decay = none;\n    /**\r\n     * While animating, round to the nearest multiple of this number.\r\n     * The `from` and `to` values are never rounded, as well as any value\r\n     * passed to the `set` method of an animated value.\r\n     */\n\n    this.round = none;\n  }\n  /* might be reintroduced later */\n\n  /**\r\n   * @internal\r\n   * The angular frequency in rad/ms\r\n   */\n  // w0 = 0\n\n  /**\r\n   * Partially overwrite the existing config.\r\n   */\n\n\n  merge(config) {\n    const {\n      mass,\n      frequency,\n      damping\n    } = Object.assign(this, config); // Derive \"tension\" and \"friction\" from \"frequency\" and \"damping\".\n\n    if (!is.und(frequency)) {\n      this.tension = Math.pow(frequency, 2) * mass;\n      this.friction = damping * Math.sqrt(this.tension * mass) / 0.5;\n    }\n    /* might be reintroduced later */\n    // Cache the angular frequency in rad/ms\n    // this.w0 = Math.sqrt(this.tension / mass) / 1000\n\n  }\n\n}\n\nconst isFrameValue = value => value instanceof FrameValue;\nlet nextId = 1;\n/**\r\n * A kind of `FluidValue` that manages an `AnimatedValue` node.\r\n *\r\n * Its underlying value can be accessed and even observed.\r\n */\n\nclass FrameValue extends FluidValue {\n  constructor() {\n    super(...arguments);\n    this.id = nextId++;\n    this._priority = 0;\n    this._children = new Set();\n  }\n\n  get priority() {\n    return this._priority;\n  }\n\n  set priority(priority) {\n    if (this._priority != priority) {\n      this._priority = priority;\n\n      this._onPriorityChange(priority);\n    }\n  }\n\n  get velocity() {\n    const node = getAnimated(this);\n    return node instanceof AnimatedValue ? node.lastVelocity || 0 : node.getPayload().map(node => node.lastVelocity || 0);\n  }\n  /** Get the current value */\n\n\n  get() {\n    const node = getAnimated(this);\n    return node && node.getValue();\n  }\n  /** Create a spring that maps our value to another value */\n\n\n  to(...args) {\n    return to$1(this, args);\n  }\n  /** @deprecated Use the `to` method instead. */\n\n\n  interpolate(...args) {\n    deprecateInterpolate();\n    return to$1(this, args);\n  }\n  /** @internal */\n\n\n  addChild(child) {\n    if (!this._children.size) this._attach();\n\n    this._children.add(child);\n  }\n  /** @internal */\n\n\n  removeChild(child) {\n    this._children.delete(child);\n\n    if (!this._children.size) this._detach();\n  }\n  /** @internal */\n\n\n  onParentChange(event) {\n    if (event.type == 'reset') {\n      this._reset(event.goal);\n    } else if (event.type == 'start') {\n      this._start();\n    }\n  }\n  /** Called when the first child is added. */\n\n\n  _attach() {}\n  /** Called when the last child is removed. */\n\n\n  _detach() {}\n  /** Reset the animation state of this value and every descendant */\n\n\n  _reset(goal) {\n    this._emit({\n      type: 'reset',\n      parent: this,\n      goal\n    });\n  }\n  /** Enter the frameloop if possible */\n\n\n  _start() {\n    this._emit({\n      type: 'start',\n      parent: this\n    });\n  }\n  /** Notify observers of a change to our value */\n\n\n  _onChange(value, idle = false) {\n    this._emit({\n      type: 'change',\n      parent: this,\n      value,\n      idle\n    });\n  }\n  /** Notify observers of a change to our priority */\n\n\n  _onPriorityChange(priority) {\n    if (!this.idle) {\n      frameLoop.start(this);\n    }\n\n    this._emit({\n      type: 'priority',\n      parent: this,\n      priority\n    });\n  }\n\n  _emit(event) {\n    // Clone \"_children\" so it can be safely mutated inside the loop.\n    each(Array.from(this._children), child => {\n      child.onParentChange(event);\n    });\n  }\n\n}\n\n/** The spring cannot be animated */\n\nconst DISPOSED = 'DISPOSED';\n/** The spring has not animated yet */\n\nconst CREATED = 'CREATED';\n/** The spring has animated before */\n\nconst IDLE = 'IDLE';\n/** The spring is frozen in time */\n\nconst PAUSED = 'PAUSED';\n/** The spring is animating */\n\nconst ACTIVE = 'ACTIVE';\n/** An opaque animatable value */\n\nclass SpringValue extends FrameValue {\n  constructor(arg1, arg2) {\n    super();\n    /** The animation state */\n\n    this.animation = new Animation();\n    /** The lifecycle phase of this spring */\n\n    this._phase = CREATED;\n    /** The state for `runAsync` calls */\n\n    this._state = {};\n    /** The last time each prop changed */\n\n    this._timestamps = {};\n    /** Some props have customizable default values */\n\n    this._defaultProps = {};\n    /** Cancel any update from before this timestamp */\n\n    this._lastAsyncId = 0;\n\n    if (arguments.length) {\n      this.start(is.obj(arg1) ? arg1 : _extends({}, arg2, {\n        from: arg1\n      }));\n    }\n  }\n\n  get idle() {\n    return !this.is(ACTIVE);\n  }\n  /** Advance the current animation by a number of milliseconds */\n\n\n  advance(dt) {\n    let idle = true;\n    let changed = false;\n    const anim = this.animation;\n    const payload = getPayload(anim.to);\n    let {\n      toValues\n    } = anim;\n\n    if (!payload) {\n      const toConfig = getFluidConfig(anim.to);\n      if (toConfig) toValues = toArray(toConfig.get());\n    }\n\n    anim.values.forEach((node, i) => {\n      if (node.done) return; // The \"anim.toValues\" array must exist when no parent exists.\n\n      let to = payload ? payload[i].lastPosition : toValues[i]; // Parent springs must finish before their children can.\n\n      const canFinish = !payload || payload[i].done; // Jump to end value for immediate animations.\n\n      if (anim.immediate) {\n        node.done = canFinish || (idle = false);\n\n        if (node.setValue(to)) {\n          changed = true;\n        }\n\n        return;\n      }\n\n      const {\n        config\n      } = anim; // Loose springs never move.\n\n      if (config.tension == 0) {\n        node.done = true;\n        return;\n      }\n\n      const elapsed = node.elapsedTime += dt;\n      const from = anim.fromValues[i];\n      const v0 = node.v0 != null ? node.v0 : node.v0 = is.arr(config.velocity) ? config.velocity[i] : config.velocity;\n      let position = node.lastPosition;\n      let velocity;\n      let finished; // Duration easing\n\n      if (!is.und(config.duration)) {\n        let p = config.progress || 0;\n        if (config.duration <= 0) p = 1;else p += (1 - p) * Math.min(1, elapsed / config.duration);\n        position = from + config.easing(p) * (to - from);\n        velocity = (position - node.lastPosition) / dt;\n        finished = p == 1;\n      } // Decay easing\n      else if (config.decay) {\n          const decay = config.decay === true ? 0.998 : config.decay;\n          const e = Math.exp(-(1 - decay) * elapsed);\n          position = from + v0 / (1 - decay) * (1 - e); // derivative of position\n\n          velocity = v0 * e;\n          finished = Math.abs(node.lastPosition - position) < 0.1;\n          if (finished) to = position;\n        } // Spring easing\n        else {\n            velocity = node.lastVelocity == null ? v0 : node.lastVelocity;\n            /** The smallest distance from a value before being treated like said value. */\n\n            const precision = config.precision || (from == to ? 0.005 : Math.min(1, Math.abs(to - from) * 0.001));\n            /** The velocity at which movement is essentially none */\n\n            const restVelocity = config.restVelocity || precision; // Bouncing is opt-in (not to be confused with overshooting)\n\n            const bounceFactor = config.clamp ? 0 : config.bounce;\n            const canBounce = !is.und(bounceFactor);\n            /** When `true`, the value is increasing over time */\n\n            const isGrowing = from == to ? node.v0 > 0 : from < to;\n            /** When `true`, the velocity is considered moving */\n\n            let isMoving;\n            /** When `true`, the velocity is being deflected or clamped */\n\n            let isBouncing = false; //const step = 0.05 / config.w0\n\n            const step = 1; // 1ms\n\n            const numSteps = Math.ceil(dt / step);\n\n            for (let n = 0; n < numSteps; ++n) {\n              isMoving = Math.abs(velocity) > restVelocity;\n\n              if (!isMoving) {\n                finished = Math.abs(to - position) <= precision;\n\n                if (finished) {\n                  break;\n                }\n              }\n\n              if (canBounce) {\n                isBouncing = position == to || position > to == isGrowing; // Invert the velocity with a magnitude, or clamp it.\n\n                if (isBouncing) {\n                  velocity = -velocity * bounceFactor;\n                  position = to;\n                }\n              }\n\n              const springForce = -config.tension * 0.000001 * (position - to);\n              const dampingForce = -config.friction * 0.001 * velocity;\n              const acceleration = (springForce + dampingForce) / config.mass; // pt/ms^2\n\n              velocity = velocity + acceleration * step; // pt/ms\n\n              position = position + velocity * step;\n            }\n          }\n\n      if (Number.isNaN(position)) {\n        console.warn(`Got NaN while animating:`, this);\n        return this.finish();\n      }\n\n      if (finished && canFinish) {\n        node.done = true;\n      } else {\n        idle = false;\n      }\n\n      node.lastVelocity = velocity;\n\n      if (node.setValue(position, config.round)) {\n        changed = true;\n      }\n    });\n\n    if (idle) {\n      this.finish();\n    } else if (changed) {\n      this._onChange(this.get());\n    }\n\n    return idle;\n  }\n  /** Check the current phase */\n\n\n  is(phase) {\n    return this._phase == phase;\n  }\n  /** Set the current value, while stopping the current animation */\n\n\n  set(value) {\n    if (this._set(value) && this.idle) {\n      // Since \"_stop\" calls \"_onChange\" only when not idle, we need this.\n      this._onChange(this.get(), true);\n    }\n\n    this._stop();\n\n    return this;\n  }\n  /**\r\n   * Freeze the active animation in time.\r\n   * This does nothing when not animating.\r\n   *\r\n   * Call `start` to unpause.\r\n   */\n\n\n  pause() {\n    checkDisposed(this, 'pause');\n    this._phase = PAUSED;\n  }\n  /**\r\n   * Skip to the end of the current animation.\r\n   *\r\n   * All `onRest` callbacks are passed `{finished: true}`\r\n   */\n\n\n  finish(to) {\n    if (!this.idle) {\n      const anim = this.animation; // Decay animations have an implicit goal.\n\n      if (!anim.config.decay && is.und(to)) {\n        to = anim.to;\n      } // Set the value if we can.\n\n\n      if (!is.und(to)) {\n        this._set(to);\n      } // Exit the frameloop.\n\n\n      this._stop(true);\n    }\n\n    return this;\n  }\n  /** Push props into the pending queue. */\n\n\n  update(props) {\n    checkDisposed(this, 'update'); // Ensure the initial value can be accessed by animated components.\n\n    this.setNodeWithProps(props);\n    const queue = this.queue || (this.queue = []);\n    queue.push(props);\n    return this;\n  }\n\n  async start(to, arg2) {\n    checkDisposed(this, 'start'); // Unpause if possible.\n\n    if (this.is(PAUSED)) {\n      this._start();\n\n      if (this._state.asyncTo) {\n        this._state.unpause();\n      }\n    }\n\n    let queue;\n\n    if (!is.und(to)) {\n      queue = [is.obj(to) ? to : _extends({}, arg2, {\n        to\n      })];\n    } else {\n      queue = this.queue || [];\n      this.queue = [];\n    }\n\n    await Promise.all(queue.map(props => this._animate(props)));\n    return {\n      finished: true,\n      value: this.get(),\n      spring: this\n    };\n  }\n  /**\r\n   * Stop the current animation, and cancel any delayed updates.\r\n   */\n\n\n  stop() {\n    if (!this.is(DISPOSED)) {\n      this._state.cancelId = this._lastAsyncId;\n\n      this._to(this.get());\n\n      this._stop();\n    }\n\n    return this;\n  }\n  /** Restart the animation. */\n\n\n  reset() {\n    this._animate({\n      reset: true\n    });\n  }\n  /** Prevent future animations, and stop the current animation */\n\n\n  dispose() {\n    if (!this.is(DISPOSED)) {\n      if (this.animation) {\n        // Prevent \"onRest\" calls when disposed.\n        this.animation.onRest = undefined;\n      }\n\n      this.stop();\n      this._phase = DISPOSED;\n    }\n  }\n  /** @internal */\n\n\n  onParentChange(event) {\n    super.onParentChange(event);\n\n    if (this.idle && event.type == 'change') {\n      const anim = this.animation;\n\n      if (!anim.immediate) {\n        anim.fromValues = anim.values.map(node => node.lastPosition);\n      } // Enter the frameloop when a parent changes.\n\n\n      this._start();\n    } else if (event.type == 'priority') {\n      this.priority = event.priority + 1;\n    }\n  }\n  /**\r\n   * Analyze the given `value` to determine which data type is being animated.\r\n   * Then, create an `Animated` node for that data type and make it our `node`.\r\n   */\n\n\n  _ensureAnimated(value) {\n    if (value != null) {\n      const nodeType = this._getNodeType(value);\n\n      setAnimated(this, nodeType.create(computeGoal(value)));\n    }\n  }\n  /**\r\n   * @internal\r\n   * Analyze the given `props` to determine which data type is being animated.\r\n   * Then, create an `Animated` node for that data type and make it our `node`.\r\n   * If we already have a `node`, do nothing but return the `{from, to}` range.\r\n   */\n\n\n  setNodeWithProps(props) {\n    const range = this._getRange(props);\n\n    if (!getAnimated(this)) {\n      this._ensureAnimated(range.from != null ? range.from : range.to);\n    }\n\n    return range;\n  }\n  /** Return the `Animated` node constructor for a given value */\n\n\n  _getNodeType(value) {\n    const parentNode = getAnimated(value);\n\n    if (parentNode) {\n      const parentType = parentNode.constructor;\n      return parentType == AnimatedString ? AnimatedValue : parentType;\n    }\n\n    return is.arr(value) ? AnimatedArray : isAnimatedString(value) ? AnimatedString : AnimatedValue;\n  }\n  /** Pluck the `to` and `from` props */\n\n\n  _getRange(props) {\n    const {\n      to,\n      from\n    } = props;\n    const key = this.key || '';\n    return {\n      to: !is.obj(to) || getFluidConfig(to) ? to : to[key],\n      from: !is.obj(from) || getFluidConfig(from) ? from : from[key]\n    };\n  }\n  /** Schedule an animation to run after an optional delay */\n\n\n  _animate(props) {\n    // Ensure the initial value can be accessed by animated components.\n    const range = this.setNodeWithProps(props);\n    const state = this._state;\n    const timestamp = now();\n    return scheduleProps(++this._lastAsyncId, {\n      key: this.key,\n      props,\n      state,\n      action: (props, resolve) => {\n        const {\n          to\n        } = props;\n\n        if (is.arr(to) || is.fun(to)) {\n          resolve(runAsync(to, props, state, () => this.get(), () => this.is(PAUSED), this.start.bind(this), this.stop.bind(this)));\n        } else if (props.cancel) {\n          this.stop();\n          resolve({\n            value: this.get(),\n            cancelled: true\n          });\n        } else {\n          this._update(range, props, timestamp, resolve);\n        }\n      }\n    });\n  }\n  /** Update the current animation */\n\n\n  _update({\n    to,\n    from\n  }, props, timestamp, resolve) {\n    const defaultProps = this._defaultProps;\n    /** Get the value of a prop, or its default value */\n\n    const get = prop => !is.und(props[prop]) ? props[prop] : defaultProps[prop];\n\n    const onAnimate = get('onAnimate');\n\n    if (onAnimate) {\n      onAnimate(props, this);\n    } // Cast from a partial type.\n\n\n    const anim = this.animation;\n    const timestamps = this._timestamps;\n    /** Return true if our prop can be used. This only affects delayed props. */\n\n    const diff = prop => {\n      if (timestamp >= (timestamps[prop] || 0)) {\n        timestamps[prop] = timestamp;\n        return true;\n      }\n\n      return false;\n    };\n\n    const {\n      to: prevTo,\n      from: prevFrom\n    } = anim; // The \"reverse\" prop only affects one update.\n\n    if (props.reverse) [to, from] = [from, to];\n\n    if (!is.und(to) && diff('to')) {\n      this._to(to);\n    } else {\n      to = prevTo;\n    }\n\n    if (!is.und(from) && diff('from')) {\n      anim.from = from;\n    } else {\n      from = anim.from;\n    }\n\n    const toConfig = getFluidConfig(to);\n    const fromConfig = getFluidConfig(from);\n\n    if (fromConfig) {\n      from = fromConfig.get();\n    }\n\n    const reset = props.reset && !is.und(from);\n    const changed = !is.und(to) && !isEqual(to, prevTo);\n    /** The current value */\n\n    let value = reset ? from : this.get();\n\n    if (is.und(from)) {\n      from = value;\n    }\n    /** When true, this spring must be in the frameloop. */\n\n\n    let started = !!toConfig || (changed || reset) && !isEqual(value, to);\n    /** The initial velocity before this `animate` call. */\n\n    const lastVelocity = anim.config ? anim.config.velocity : 0; // The \"config\" prop either overwrites or merges into the existing config.\n\n    if (!anim.config || props.config || started) {\n      const config = _extends({}, callProp(defaultProps.config, this.key), callProp(props.config, this.key));\n\n      if (!canMergeConfigs(config, anim.config)) {\n        anim.config = new AnimationConfig();\n      }\n\n      anim.config.merge(config);\n    }\n\n    const {\n      config\n    } = anim; // Always start animations with velocity.\n\n    if (!started && (config.decay || !is.und(to))) {\n      started = !isEqual(config.velocity, lastVelocity);\n    } // Reset our internal `Animated` node if starting.\n\n\n    let node = getAnimated(this);\n    let nodeType;\n\n    if (changed) {\n      nodeType = this._getNodeType(to);\n\n      if (nodeType !== node.constructor) {\n        throw Error(`Cannot animate to the given \"to\" prop, because the current value has a different type`);\n      }\n    } else {\n      nodeType = node.constructor;\n    } // The final value of our animation, excluding the \"to\" value.\n    // Our goal value is dynamic when \"toConfig\" exists.\n\n\n    let goal = toConfig ? null : computeGoal(to);\n\n    if (nodeType == AnimatedString) {\n      from = 0;\n      goal = 1;\n    } // Ensure the current value equals the \"from\" value when reset\n    // and when the \"from\" value is updated before the first animation.\n\n\n    if (reset || this.is(CREATED) && !is.und(anim.from) && !isEqual(anim.from, prevFrom)) {\n      node.setValue(value = from);\n    } // Event props are replaced on every update.\n\n\n    anim.onStart = get('onStart');\n    anim.onChange = get('onChange'); // Update the default props.\n\n    if (props.default) {\n      each(DEFAULT_PROPS, prop => {\n        // Default props can only be null, an object, or a function.\n        if (/function|object/.test(typeof props[prop])) {\n          defaultProps[prop] = props[prop];\n        }\n      });\n    }\n\n    if (!started) {\n      // Resolve the \"animate\" promise.\n      return resolve({\n        value,\n        spring: this,\n        finished: true\n      });\n    }\n\n    anim.values = node.getPayload();\n    anim.toValues = toConfig ? null : toArray(goal);\n    anim.immediate = // Sometimes the value is not animatable.\n    !(toConfig || is.num(goal) || is.arr(goal)) || !!matchProp(get('immediate'), this.key); // Avoid calling this before \"immediate\" is set\n\n    this._reset();\n\n    const onRestQueue = anim.onRest; // The \"onRest\" prop is always first in the queue.\n\n    anim.onRest = [get('onRest') || noop, resolve]; // Resolve the promise for unfinished animations.\n\n    if (onRestQueue && onRestQueue.length > 1) {\n      const result = {\n        value,\n        spring: this,\n        cancelled: true\n      }; // Skip the \"onRest\" prop, as the animation is still active.\n\n      for (let i = 1; i < onRestQueue.length; i++) {\n        onRestQueue[i](result);\n      }\n    }\n\n    this._start();\n  }\n  /** Update the `animation.to` value, which might be a `FluidValue` */\n\n\n  _to(value) {\n    const anim = this.animation;\n    if (value === anim.to) return;\n    let config = getFluidConfig(anim.to);\n\n    if (config) {\n      config.removeChild(this);\n    }\n\n    anim.to = value;\n    let priority = 0;\n\n    if (config = getFluidConfig(value)) {\n      config.addChild(this);\n\n      if (isFrameValue(value)) {\n        priority = (value.priority || 0) + 1;\n      }\n    }\n\n    this.priority = priority;\n  }\n  /** Set the current value and our `node` if necessary. The `_onChange` method is *not* called. */\n\n\n  _set(value) {\n    const config = getFluidConfig(value);\n\n    if (config) {\n      value = config.get();\n    }\n\n    const node = getAnimated(this);\n\n    if (node) {\n      if (isEqual(value, node.getValue())) {\n        return false;\n      }\n\n      node.setValue(value);\n    } else {\n      this._ensureAnimated(value);\n    }\n\n    return true;\n  }\n  /** Notify change observers */\n\n\n  _onChange(value, idle = false) {\n    const anim = this.animation;\n\n    if (!anim.changed && !idle) {\n      anim.changed = true; // The \"onStart\" prop is called on the first change after entering the\n      // frameloop, but never for immediate animations.\n\n      if (anim.onStart) {\n        anim.onStart(this);\n      }\n    }\n\n    if (anim.onChange) {\n      anim.onChange(value, this);\n    }\n\n    super._onChange(value, idle);\n  }\n  /** Reset our node, and the nodes of every descendant spring */\n\n\n  _reset(goal) {\n    const anim = this.animation;\n\n    if (is.und(goal)) {\n      goal = computeGoal(anim.to);\n    }\n\n    getAnimated(this).reset(goal);\n\n    super._reset(goal);\n\n    if (!anim.immediate) {\n      anim.fromValues = anim.values.map(node => node.lastPosition);\n    }\n  }\n  /** Enter the frameloop */\n\n\n  _start() {\n    if (this.idle) {\n      this._phase = ACTIVE; // Animations without \"onRest\" cannot enter the frameloop.\n\n      const anim = this.animation;\n\n      if (anim.onRest) {\n        anim.changed = false; // The \"skipAnimation\" global avoids the frameloop.\n\n        if (skipAnimation) {\n          this.finish(anim.to);\n        } else {\n          frameLoop.start(this);\n        }\n      }\n\n      super._start();\n    }\n  }\n  /** Exit the frameloop and notify `onRest` listeners */\n\n\n  _stop(finished = false) {\n    if (!this.idle) {\n      this._phase = IDLE; // Always let change observers know when a spring becomes idle.\n\n      this._onChange(this.get(), true);\n\n      const anim = this.animation;\n      const onRestQueue = anim.onRest; // Animations without \"onRest\" never enter the frameloop.\n\n      if (onRestQueue) {\n        each(anim.values, node => {\n          node.done = true;\n        }); // Preserve the \"onRest\" prop between animations.\n\n        anim.onRest = [onRestQueue[0]]; // Never call the \"onRest\" prop for immediate or no-op animations.\n\n        if (anim.immediate || !anim.changed) {\n          onRestQueue[0] = noop;\n        }\n\n        batchedUpdates(() => {\n          const result = {\n            value: this.get(),\n            spring: this,\n            finished\n          };\n          each(onRestQueue, onRest => {\n            onRest(result);\n          });\n        });\n      }\n    }\n  }\n\n} // TODO: makes this tree-shakeable\n\nfunction checkDisposed(spring, name) {\n  if (spring.is(DISPOSED)) {\n    throw Error(`Cannot call \"${name}\" of disposed \"${spring.constructor.name}\" object`);\n  }\n} // Merge configs when the existence of \"decay\" or \"duration\" has not changed.\n\n\nfunction canMergeConfigs(src, dest) {\n  return !!dest && is.und(src.decay) == is.und(dest.decay) && is.und(src.duration) == is.und(dest.duration) && is.und(src.frequency) == is.und(dest.frequency);\n} // Compute the goal value, converting \"red\" to \"rgba(255, 0, 0, 1)\" in the process\n\n\nfunction computeGoal(value) {\n  const config = getFluidConfig(value);\n  return config ? computeGoal(config.get()) : is.arr(value) ? value.map(computeGoal) : isAnimatedString(value) ? createStringInterpolator({\n    range: [0, 1],\n    output: [value, value]\n  })(1) : value;\n}\n\nlet nextId$1 = 1;\nlet lastAsyncId = 0;\nclass Controller {\n  constructor(props) {\n    this.id = nextId$1++;\n    /** The values that changed in the last animation frame */\n\n    this.frame = {};\n    /** Fallback values for undefined props */\n\n    this.defaultProps = {};\n    /** The queue of pending props */\n\n    this.queue = [];\n    /** The current controller-only props (eg: `onFrame` and async state) */\n\n    this._state = {};\n    /** The spring values that manage their animations */\n\n    this._springs = {};\n    this._onFrame = this._onFrame.bind(this);\n\n    if (props) {\n      props.default = true;\n      this.start(props);\n    }\n  }\n  /** Equals true when no springs are animating */\n\n\n  get idle() {\n    return !this._state.promise && Object.values(this._springs).every(s => s.idle);\n  }\n  /** Get all existing `SpringValue` objects. This clones the internal store. */\n\n\n  get springs() {\n    return _extends({}, this._springs);\n  }\n\n  get(key) {\n    return this._springs[key];\n  }\n  /** Push an update onto the queue of each value. */\n\n\n  update(props) {\n    if (props) this.queue.push(this._update(props));\n    return this;\n  }\n  /**\r\n   * Start the queued animations for every spring, and resolve the returned\r\n   * promise once all queued animations have finished or been cancelled.\r\n   *\r\n   * When you pass a queue (instead of nothing), that queue is used instead of\r\n   * the queued animations added with the `update` method, which are left alone.\r\n   */\n\n\n  async start(queue) {\n    if (queue) {\n      queue = toArray(queue).map(props => this._update(props));\n    } else {\n      queue = this.queue;\n      this.queue = [];\n    }\n\n    const promises = [];\n    each(queue, props => {\n      const {\n        to,\n        onFrame,\n        keys\n      } = props;\n      const asyncTo = (is.arr(to) || is.fun(to)) && to;\n\n      if (asyncTo) {\n        props.to = undefined;\n      }\n\n      const state = this._state;\n      promises.push( // Send updates to every affected key.\n      ...keys.map(key => this._springs[key].start(props)), // Schedule controller-only props.\n      scheduleProps(++lastAsyncId, {\n        props,\n        state,\n        action: (props, resolve) => {\n          if (!props.cancel) {\n            // Never reuse \"onFrame\" from a previous update.\n            state.onFrame = onFrame || this.defaultProps.onFrame;\n\n            if (onFrame && props.default) {\n              this.defaultProps.onFrame = onFrame;\n            }\n          } // Start, replace, or cancel the async animation.\n\n\n          if (asyncTo) {\n            resolve(runAsync(asyncTo, props, state, this._get.bind(this), () => false, // TODO: add pausing to Controller\n            this.start.bind(this), this.stop.bind(this)));\n          } else {\n            resolve({\n              value: 0,\n              finished: !props.cancel\n            });\n          }\n        }\n      }));\n    });\n    const results = await Promise.all(promises);\n    return {\n      value: this._get(),\n      finished: results.every(result => result.finished)\n    };\n  }\n  /** Stop one animation, some animations, or all animations */\n\n\n  stop(keys) {\n    if (is.und(keys)) {\n      each(this._springs, spring => spring.stop());\n    } else {\n      each(toArray(keys), key => this._springs[key].stop());\n    }\n\n    return this;\n  }\n  /** Restart every animation. */\n\n\n  reset() {\n    each(this._springs, spring => spring.reset()); // TODO: restart async \"to\" prop\n\n    return this;\n  }\n  /** Destroy every spring in this controller */\n\n\n  dispose() {\n    this._state.asyncTo = undefined;\n    each(this._springs, spring => spring.dispose());\n    this._springs = {};\n  }\n  /** Get the current value of every spring */\n\n\n  _get() {\n    const values = {};\n    each(this._springs, (spring, key) => {\n      values[key] = spring.get();\n    });\n    return values;\n  }\n  /** Create a spring for every given key, and ensure they have `Animated` nodes. */\n\n\n  _setSprings(keys, from, to) {\n    each(keys, key => {\n      if (!this._springs[key]) {\n        const spring = this._springs[key] = new SpringValue();\n        spring.key = key;\n        spring.addChild(this);\n        spring.setNodeWithProps({\n          from,\n          to\n        });\n      }\n    });\n  }\n  /** Prepare an update with the given props. */\n\n\n  _update(propsArg) {\n    const props = interpolateTo(propsArg);\n    const keys = props.keys = extractKeys(props, this._springs);\n    let {\n      from,\n      to\n    } = props; // Avoid sending async \"to\" prop to springs.\n\n    if (is.arr(to) || is.fun(to)) {\n      to = undefined;\n    } // Create our springs and give them values.\n\n\n    if (from || to) {\n      this._setSprings(keys, from, to);\n    }\n\n    return props;\n  }\n  /** @internal */\n\n\n  onParentChange(event) {\n    if (this._state.onFrame && event.type == 'change') {\n      this.frame[event.parent.key] = event.value;\n      frameLoop.onFrame(this._onFrame);\n    }\n  }\n  /** @internal Called at the end of every animation frame */\n\n\n  _onFrame() {\n    if (Object.keys(this.frame).length) {\n      this._state.onFrame(this.frame);\n\n      this.frame = {};\n    }\n  }\n\n}\n/** Determine which keys should receive an update */\n\nfunction extractKeys(props, springs) {\n  const keys = new Set();\n  /** Collect keys with a defined value */\n\n  const getDefinedKeys = obj => each(obj, (value, key) => {\n    if (!is.und(value)) {\n      keys.add(key);\n    }\n  });\n\n  const {\n    from,\n    to\n  } = props;\n  if (is.obj(to)) getDefinedKeys(to);\n  if (from) getDefinedKeys(from); // When neither \"from\" or \"to\" have a key with a defined value,\n  // return the keys for every existing spring.\n\n  return keys.size ? Array.from(keys) : Object.keys(springs);\n}\n\n/** @internal */\n\nfunction useSprings(length, props, deps) {\n  const propsFn = is.fun(props) && props;\n\n  if (propsFn && arguments.length < 3) {\n    deps = []; // Skip updates after first render.\n  } // The \"ref\" prop is taken from the props of the first spring only.\n  // The ref is assumed to *never* change after the first render.\n\n\n  let ref;\n  const ctrls = useMemo(() => [], []);\n  const updates = [];\n  const prevLength = usePrev(length) || 0;\n  useMemo(() => {\n    if (prevLength > length) {\n      for (let i = length; i < prevLength; i++) {\n        ctrls[i].dispose();\n      }\n    }\n\n    ctrls.length = length;\n\n    for (let i = 0; i < length; i++) {\n      const ctrl = ctrls[i] || (ctrls[i] = new Controller());\n      const update = propsFn ? propsFn(i, ctrl) : props[i];\n\n      if (update) {\n        update.default = true;\n\n        if (i == 0 && update.ref) {\n          ref = update.ref;\n        }\n\n        if (i < prevLength) {\n          updates[i] = update;\n        } else {\n          // Update new controllers immediately, so their\n          // spring values exist during first render.\n          ctrl.update(update);\n        }\n      }\n    }\n  }, deps);\n  const api = useMemo$1(() => ({\n    get controllers() {\n      return ctrls;\n    },\n\n    update: props => {\n      each(ctrls, (ctrl, i) => {\n        ctrl.update(getProps(props, i, ctrl));\n        if (!ref) ctrl.start();\n      });\n      return api;\n    },\n\n    async start() {\n      const results = await Promise.all(ctrls.map(ctrl => ctrl.start()));\n      return {\n        value: results.map(result => result.value),\n        finished: results.every(result => result.finished)\n      };\n    },\n\n    stop: keys => each(ctrls, ctrl => ctrl.stop(keys))\n  }), []);\n  useImperativeHandle(ref, () => api);\n  useIsomorphicLayoutEffect(() => {\n    each(updates, (update, i) => ctrls[i].update(update));\n\n    if (!ref) {\n      each(ctrls, ctrl => ctrl.start());\n    }\n  }, deps);\n  useOnce(() => () => {\n    each(ctrls, ctrl => ctrl.dispose());\n  });\n  const values = ctrls.map(ctrl => ctrl.springs);\n  return propsFn || arguments.length == 3 ? [values, api.update, api.stop] : values;\n}\n\n/** @internal */\n\nfunction useSpring(props, deps) {\n  const isFn = is.fun(props);\n  const [[values], update, stop] = useSprings(1, isFn ? props : [props], deps);\n  return isFn || arguments.length == 3 ? [values, update, stop] : values;\n}\n\nfunction useTrail(length, propsArg, deps) {\n  const propsFn = is.fun(propsArg) && propsArg;\n\n  if (propsFn && arguments.length < 3) {\n    deps = []; // Skip updates after first render.\n  }\n\n  const ctrls = [];\n  const result = useSprings(length, (i, ctrl) => {\n    ctrls[i] = ctrl;\n    return getProps(propsArg, i, ctrl);\n  }, deps);\n  useIsomorphicLayoutEffect(() => {\n    const reverse = is.obj(propsArg) && propsArg.reverse;\n\n    for (let i = 0; i < ctrls.length; i++) {\n      const parent = ctrls[i + (reverse ? 1 : -1)];\n      if (parent) ctrls[i].update({\n        to: parent.springs\n      }).start();\n    }\n  }, deps);\n  const update = result[1];\n\n  result[1] = propsArg => {\n    const reverse = is.obj(propsArg) && propsArg.reverse;\n    return update((i, ctrl) => {\n      const props = getProps(propsArg, i, ctrl);\n      const parent = ctrls[i + (reverse ? 1 : -1)];\n      if (parent) props.to = parent.springs;\n      return props;\n    });\n  };\n\n  return propsFn ? result : result[0];\n}\n\n/** This transition is being mounted */\n\nconst MOUNT = 0;\n/** This transition is entering or has entered */\n\nconst ENTER = 1;\n/** This transition had its animations updated */\n\nconst UPDATE = 2;\n/** This transition will expire after animating */\n\nconst LEAVE = 3;\n\nfunction getKeys(items, {\n  key,\n  keys = key\n}) {\n  return is.und(keys) ? items : is.fun(keys) ? items.map(keys) : toArray(keys);\n}\n\nfunction useTransition(data, props, deps) {\n  const {\n    ref,\n    reset,\n    sort,\n    trail = 0,\n    expires = Infinity\n  } = props; // Every item has its own transition.\n\n  const items = toArray(data);\n  const transitions = []; // Keys help with reusing transitions between renders.\n  // The `key` prop can be undefined (which means the items themselves are used\n  // as keys), or a function (which maps each item to its key), or an array of\n  // keys (which are assigned to each item by index).\n\n  const keys = getKeys(items, props); // The \"onRest\" callbacks need a ref to the latest transitions.\n\n  const usedTransitions = useRef(null);\n  const prevTransitions = usedTransitions.current;\n  useIsomorphicLayoutEffect(() => {\n    usedTransitions.current = transitions;\n  }); // Destroy all transitions on dismount.\n\n  useOnce(() => () => each(usedTransitions.current, t => {\n    if (t.expiresBy != null) {\n      clearTimeout(t.expirationId);\n    }\n\n    t.ctrl.dispose();\n  })); // Map old indices to new indices.\n\n  const reused = [];\n  if (prevTransitions && !reset) each(prevTransitions, (t, i) => {\n    // Expired transitions are not rendered.\n    if (t.expiresBy != null) {\n      clearTimeout(t.expirationId);\n    } else {\n      i = reused[i] = keys.indexOf(t.key);\n      if (~i) transitions[i] = t;\n    }\n  }); // Mount new items with fresh transitions.\n\n  each(items, (item, i) => {\n    transitions[i] || (transitions[i] = {\n      key: keys[i],\n      item,\n      phase: MOUNT,\n      ctrl: new Controller()\n    });\n  }); // Update the item of any transition whose key still exists,\n  // and ensure leaving transitions are rendered until they finish.\n\n  if (reused.length) {\n    let i = -1;\n    each(reused, (keyIndex, prevIndex) => {\n      const t = prevTransitions[prevIndex];\n\n      if (~keyIndex) {\n        i = transitions.indexOf(t);\n        transitions[i] = _extends({}, t, {\n          item: items[keyIndex]\n        });\n      } else if (props.leave) {\n        transitions.splice(++i, 0, t);\n      }\n    });\n  }\n\n  if (is.fun(sort)) {\n    transitions.sort((a, b) => sort(a.item, b.item));\n  } // Track cumulative delay for the \"trail\" prop.\n\n\n  let delay = -trail; // Expired transitions use this to dismount.\n\n  const forceUpdate = useForceUpdate();\n  const defaultProps = {};\n  each(DEFAULT_PROPS, prop => {\n    if (/function|object/.test(typeof props[prop])) {\n      defaultProps[prop] = props[prop];\n    }\n  }); // Generate changes to apply in useEffect.\n\n  const changes = new Map();\n  each(transitions, (t, i) => {\n    let to;\n    let from;\n    let phase;\n\n    if (t.phase == MOUNT) {\n      to = props.enter;\n      phase = ENTER; // The \"initial\" prop is only used on first render. It always overrides\n      // the \"from\" prop when defined, and it makes \"enter\" instant when null.\n\n      from = props.initial;\n\n      if (is.und(from) || prevTransitions && !reset) {\n        from = props.from;\n      }\n    } else {\n      const isLeave = keys.indexOf(t.key) < 0;\n\n      if (t.phase < LEAVE) {\n        if (isLeave) {\n          to = props.leave;\n          phase = LEAVE;\n        } else if (to = props.update) {\n          phase = UPDATE;\n        } else return;\n      } else if (!isLeave) {\n        to = props.enter;\n        phase = ENTER;\n      } else return;\n    } // The payload is used to update the spring props once the current render is committed.\n\n\n    const payload = _extends({}, defaultProps, {\n      // When \"to\" is a function, it can return (1) an array of \"useSpring\" props,\n      // (2) an async function, or (3) an object with any \"useSpring\" props.\n      to: to = callProp(to, t.item, i),\n      from: callProp(from, t.item, i),\n      delay: delay += trail,\n      config: callProp(props.config || defaultProps.config, t.item, i)\n    }, is.obj(to) && interpolateTo(to));\n\n    const {\n      onRest\n    } = payload;\n\n    payload.onRest = result => {\n      if (is.fun(onRest)) {\n        onRest(result);\n      }\n\n      if (t.phase == LEAVE && t.ctrl.idle) {\n        t.expiresBy = now() + expires;\n\n        if (expires <= 0) {\n          forceUpdate();\n        } else {\n          // Postpone dismounts while other controllers are active.\n          const transitions = usedTransitions.current;\n\n          if (transitions.every(t => t.ctrl.idle)) {\n            forceUpdate();\n          } // When `expires` is infinite, postpone dismount until next render.\n          else if (expires < Infinity) {\n              t.expirationId = setTimeout(forceUpdate, expires);\n            }\n        }\n      }\n    };\n\n    const change = {\n      phase\n    };\n    changes.set(t, change); // To ensure all Animated nodes exist during render,\n    // the payload must be applied immediately for new items.\n\n    if (t.phase > MOUNT) {\n      change.payload = payload;\n    } else {\n      t.ctrl.update(payload);\n    }\n  });\n  const api = useMemo$1(() => ({\n    get controllers() {\n      return usedTransitions.current.map(t => t.ctrl);\n    },\n\n    update(props) {\n      each(usedTransitions.current, (t, i) => t.ctrl.update(is.fun(props) ? props(i, t.ctrl) : is.arr(props) ? props[i] : props));\n      return api;\n    },\n\n    async start() {\n      const transitions = usedTransitions.current;\n      const results = await Promise.all(transitions.map(t => t.ctrl.start()));\n      return {\n        value: results.map(result => result.value),\n        finished: results.every(result => result.finished)\n      };\n    },\n\n    stop: keys => each(usedTransitions.current, t => t.ctrl.stop(keys))\n  }), []);\n  useImperativeHandle(ref, () => api);\n  useIsomorphicLayoutEffect(() => {\n    each(changes, ({\n      phase,\n      payload\n    }, t) => {\n      t.phase = phase;\n      if (payload) t.ctrl.update(payload);\n      if (!ref) t.ctrl.start();\n    });\n  }, reset ? void 0 : deps);\n  return render => transitions.map(t => {\n    const elem = render(t.ctrl.springs, t.item, t);\n    return elem && elem.type ? React.createElement(elem.type, Object.assign({}, elem.props, {\n      key: is.str(t.key) || is.num(t.key) ? t.key : t.ctrl.id,\n      ref: elem.ref\n    })) : elem;\n  });\n}\n\nfunction Spring(_ref) {\n  let props = _objectWithoutPropertiesLoose(_ref, [\"children\"]);\n\n  return children(useSpring(props));\n}\nfunction Trail(_ref2) {\n  let {\n    items\n  } = _ref2,\n      props = _objectWithoutPropertiesLoose(_ref2, [\"items\", \"children\"]);\n\n  const trails = useTrail(items.length, props);\n  return items.map((item, index) => {\n    const result = children(item, index);\n    return is.fun(result) ? result(trails[index]) : result;\n  });\n}\nfunction Transition(_ref3) {\n  let props = _objectWithoutPropertiesLoose(_ref3, [\"items\", \"children\"]);\n\n  return useTransition(items, props)(children);\n}\n\n/**\r\n * An `Interpolation` is a memoized value that's computed whenever one of its\r\n * `FluidValue` dependencies has its value changed.\r\n *\r\n * Other `FrameValue` objects can depend on this. For example, passing an\r\n * `Interpolation` as the `to` prop of a `useSpring` call will trigger an\r\n * animation toward the memoized value.\r\n */\n\nclass Interpolation extends FrameValue {\n  constructor(\n  /** The source of input values */\n  source, args) {\n    super();\n    this.source = source;\n    /** Equals false when in the frameloop */\n\n    this.idle = true;\n    this.calc = createInterpolator(...args);\n\n    const value = this._get();\n\n    const nodeType = is.arr(value) ? AnimatedArray : AnimatedValue; // Assume the computed value never changes type.\n\n    setAnimated(this, nodeType.create(value));\n  }\n\n  advance(_dt) {\n    const value = this._get();\n\n    const oldValue = this.get();\n\n    if (!isEqual(value, oldValue)) {\n      getAnimated(this).setValue(value);\n\n      this._onChange(value, this.idle);\n    }\n  }\n\n  _get() {\n    const inputs = is.arr(this.source) ? this.source.map(node => node.get()) : toArray(this.source.get());\n    return this.calc(...inputs);\n  }\n\n  _start() {\n    if (this.idle) {\n      this.idle = false;\n\n      super._start();\n\n      if (skipAnimation) {\n        this.idle = true;\n        this.advance();\n      } else {\n        frameLoop.start(this);\n      }\n    }\n  }\n\n  _reset() {\n    each(getPayload(this), node => node.reset());\n\n    super._reset();\n  }\n\n  _attach() {\n    // Start observing our \"source\" once we have an observer.\n    let idle = true;\n    let priority = 1;\n    each(toArray(this.source), source => {\n      if (isFrameValue(source)) {\n        if (!source.idle) idle = false;\n        priority = Math.max(priority, source.priority + 1);\n      }\n\n      source.addChild(this);\n    });\n    this.priority = priority;\n\n    if (!idle) {\n      this._reset();\n\n      this._start();\n    }\n  }\n\n  _detach() {\n    // Stop observing our \"source\" once we have no observers.\n    each(toArray(this.source), source => {\n      source.removeChild(this);\n    });\n    this.idle = true;\n  }\n  /** @internal */\n\n\n  onParentChange(event) {\n    if (event.type == 'change') {\n      if (this.idle) {\n        this.advance();\n      } // Leave the frameloop when all parent values are done animating.\n      else if (event.idle) {\n          this.idle = toArray(this.source).every(source => source.idle !== false);\n\n          if (this.idle) {\n            this.advance();\n            each(getPayload(this), node => {\n              node.done = true;\n            });\n          }\n        }\n    } else if (event.type == 'priority') {\n      // Set our priority to 1 + the highest parent.\n      this.priority = toArray(this.source).reduce((max, source) => Math.max(max, (source.priority || 0) + 1), 0);\n    }\n\n    super.onParentChange(event);\n  }\n\n}\n\n/** Map the value of one or more dependencies */\n\nconst to = (source, ...args) => new Interpolation(source, args);\n/** @deprecated Use the `to` export instead */\n\nconst interpolate = (source, ...args) => (deprecateInterpolate(), new Interpolation(source, args));\n\nGlobals.assign({\n  applyAnimatedValues: () => false,\n  createStringInterpolator: createStringInterpolator$1,\n  to: (source, args) => new Interpolation(source, args)\n});\n/** Advance all animations forward one frame */\n\nconst update = () => Globals.frameLoop.update();\n\nexport { Controller, FrameValue, Interpolation, Spring, SpringValue, Trail, Transition, config, interpolate, isFrameValue, to, update, useChain, useSpring, useSprings, useTrail, useTransition };\n//# sourceMappingURL=index.js.map\n"]},"metadata":{},"sourceType":"module"}